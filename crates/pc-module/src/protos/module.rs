// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `module.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct Actor {
    // message fields
    pub field_type: ActorType,
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Actor {
    fn default() -> &'a Actor {
        <Actor as ::protobuf::Message>::default_instance()
    }
}

impl Actor {
    pub fn new() -> Actor {
        ::std::default::Default::default()
    }

    // .ActorType type = 1;


    pub fn get_field_type(&self) -> ActorType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ActorType::MANUAL_USER_ACTOR;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ActorType) {
        self.field_type = v;
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Actor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ActorType::MANUAL_USER_ACTOR {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ActorType::MANUAL_USER_ACTOR {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Actor {
        Actor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActorType>>(
                "type",
                |m: &Actor| { &m.field_type },
                |m: &mut Actor| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Actor| { &m.id },
                |m: &mut Actor| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Actor| { &m.name },
                |m: &mut Actor| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Actor>(
                "Actor",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Actor {
        static instance: ::protobuf::rt::LazyV2<Actor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Actor::new)
    }
}

impl ::protobuf::Clear for Actor {
    fn clear(&mut self) {
        self.field_type = ActorType::MANUAL_USER_ACTOR;
        self.id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Actor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Actor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorOwnership {
    // message fields
    pub moduleId: ::std::string::String,
    pub property: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorOwnership {
    fn default() -> &'a ActorOwnership {
        <ActorOwnership as ::protobuf::Message>::default_instance()
    }
}

impl ActorOwnership {
    pub fn new() -> ActorOwnership {
        ::std::default::Default::default()
    }

    // string moduleId = 1;


    pub fn get_moduleId(&self) -> &str {
        &self.moduleId
    }
    pub fn clear_moduleId(&mut self) {
        self.moduleId.clear();
    }

    // Param is passed by value, moved
    pub fn set_moduleId(&mut self, v: ::std::string::String) {
        self.moduleId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_moduleId(&mut self) -> &mut ::std::string::String {
        &mut self.moduleId
    }

    // Take field
    pub fn take_moduleId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.moduleId, ::std::string::String::new())
    }

    // string property = 2;


    pub fn get_property(&self) -> &str {
        &self.property
    }
    pub fn clear_property(&mut self) {
        self.property.clear();
    }

    // Param is passed by value, moved
    pub fn set_property(&mut self, v: ::std::string::String) {
        self.property = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_property(&mut self) -> &mut ::std::string::String {
        &mut self.property
    }

    // Take field
    pub fn take_property(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.property, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ActorOwnership {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.moduleId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.property)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.moduleId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.moduleId);
        }
        if !self.property.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.property);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.moduleId.is_empty() {
            os.write_string(1, &self.moduleId)?;
        }
        if !self.property.is_empty() {
            os.write_string(2, &self.property)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorOwnership {
        ActorOwnership::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "moduleId",
                |m: &ActorOwnership| { &m.moduleId },
                |m: &mut ActorOwnership| { &mut m.moduleId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "property",
                |m: &ActorOwnership| { &m.property },
                |m: &mut ActorOwnership| { &mut m.property },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorOwnership>(
                "ActorOwnership",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorOwnership {
        static instance: ::protobuf::rt::LazyV2<ActorOwnership> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorOwnership::new)
    }
}

impl ::protobuf::Clear for ActorOwnership {
    fn clear(&mut self) {
        self.moduleId.clear();
        self.property.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorOwnership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorOwnership {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActorWithOwnership {
    // message fields
    pub actor: ::protobuf::SingularPtrField<Actor>,
    pub ownerships: ::protobuf::RepeatedField<ActorOwnership>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActorWithOwnership {
    fn default() -> &'a ActorWithOwnership {
        <ActorWithOwnership as ::protobuf::Message>::default_instance()
    }
}

impl ActorWithOwnership {
    pub fn new() -> ActorWithOwnership {
        ::std::default::Default::default()
    }

    // .Actor actor = 1;


    pub fn get_actor(&self) -> &Actor {
        self.actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: Actor) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut Actor {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> Actor {
        self.actor.take().unwrap_or_else(|| Actor::new())
    }

    // repeated .ActorOwnership ownerships = 2;


    pub fn get_ownerships(&self) -> &[ActorOwnership] {
        &self.ownerships
    }
    pub fn clear_ownerships(&mut self) {
        self.ownerships.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerships(&mut self, v: ::protobuf::RepeatedField<ActorOwnership>) {
        self.ownerships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ownerships(&mut self) -> &mut ::protobuf::RepeatedField<ActorOwnership> {
        &mut self.ownerships
    }

    // Take field
    pub fn take_ownerships(&mut self) -> ::protobuf::RepeatedField<ActorOwnership> {
        ::std::mem::replace(&mut self.ownerships, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ActorWithOwnership {
    fn is_initialized(&self) -> bool {
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownerships {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ownerships)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ownerships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ownerships {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActorWithOwnership {
        ActorWithOwnership::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "actor",
                |m: &ActorWithOwnership| { &m.actor },
                |m: &mut ActorWithOwnership| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActorOwnership>>(
                "ownerships",
                |m: &ActorWithOwnership| { &m.ownerships },
                |m: &mut ActorWithOwnership| { &mut m.ownerships },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ActorWithOwnership>(
                "ActorWithOwnership",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ActorWithOwnership {
        static instance: ::protobuf::rt::LazyV2<ActorWithOwnership> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ActorWithOwnership::new)
    }
}

impl ::protobuf::Clear for ActorWithOwnership {
    fn clear(&mut self) {
        self.actor.clear();
        self.ownerships.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActorWithOwnership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorWithOwnership {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModuleData {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub readCount: i32,
    pub boardVersion: ::std::string::String,
    pub plug: bool,
    pub atIndex: i32,
    pub board: ::std::string::String,
    pub boardAddr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModuleData {
    fn default() -> &'a ModuleData {
        <ModuleData as ::protobuf::Message>::default_instance()
    }
}

impl ModuleData {
    pub fn new() -> ModuleData {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 readCount = 4;


    pub fn get_readCount(&self) -> i32 {
        self.readCount
    }
    pub fn clear_readCount(&mut self) {
        self.readCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_readCount(&mut self, v: i32) {
        self.readCount = v;
    }

    // string boardVersion = 5;


    pub fn get_boardVersion(&self) -> &str {
        &self.boardVersion
    }
    pub fn clear_boardVersion(&mut self) {
        self.boardVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_boardVersion(&mut self, v: ::std::string::String) {
        self.boardVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_boardVersion(&mut self) -> &mut ::std::string::String {
        &mut self.boardVersion
    }

    // Take field
    pub fn take_boardVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.boardVersion, ::std::string::String::new())
    }

    // bool plug = 6;


    pub fn get_plug(&self) -> bool {
        self.plug
    }
    pub fn clear_plug(&mut self) {
        self.plug = false;
    }

    // Param is passed by value, moved
    pub fn set_plug(&mut self, v: bool) {
        self.plug = v;
    }

    // int32 atIndex = 7;


    pub fn get_atIndex(&self) -> i32 {
        self.atIndex
    }
    pub fn clear_atIndex(&mut self) {
        self.atIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_atIndex(&mut self, v: i32) {
        self.atIndex = v;
    }

    // string board = 8;


    pub fn get_board(&self) -> &str {
        &self.board
    }
    pub fn clear_board(&mut self) {
        self.board.clear();
    }

    // Param is passed by value, moved
    pub fn set_board(&mut self, v: ::std::string::String) {
        self.board = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_board(&mut self) -> &mut ::std::string::String {
        &mut self.board
    }

    // Take field
    pub fn take_board(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.board, ::std::string::String::new())
    }

    // string boardAddr = 9;


    pub fn get_boardAddr(&self) -> &str {
        &self.boardAddr
    }
    pub fn clear_boardAddr(&mut self) {
        self.boardAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_boardAddr(&mut self, v: ::std::string::String) {
        self.boardAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_boardAddr(&mut self) -> &mut ::std::string::String {
        &mut self.boardAddr
    }

    // Take field
    pub fn take_boardAddr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.boardAddr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModuleData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.readCount = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.boardVersion)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.plug = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.atIndex = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.board)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.boardAddr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.readCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.readCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.boardVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.boardVersion);
        }
        if self.plug != false {
            my_size += 2;
        }
        if self.atIndex != 0 {
            my_size += ::protobuf::rt::value_size(7, self.atIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.board.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.board);
        }
        if !self.boardAddr.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.boardAddr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.readCount != 0 {
            os.write_int32(4, self.readCount)?;
        }
        if !self.boardVersion.is_empty() {
            os.write_string(5, &self.boardVersion)?;
        }
        if self.plug != false {
            os.write_bool(6, self.plug)?;
        }
        if self.atIndex != 0 {
            os.write_int32(7, self.atIndex)?;
        }
        if !self.board.is_empty() {
            os.write_string(8, &self.board)?;
        }
        if !self.boardAddr.is_empty() {
            os.write_string(9, &self.boardAddr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleData {
        ModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &ModuleData| { &m.id },
                |m: &mut ModuleData| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ModuleData| { &m.name },
                |m: &mut ModuleData| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "readCount",
                |m: &ModuleData| { &m.readCount },
                |m: &mut ModuleData| { &mut m.readCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "boardVersion",
                |m: &ModuleData| { &m.boardVersion },
                |m: &mut ModuleData| { &mut m.boardVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "plug",
                |m: &ModuleData| { &m.plug },
                |m: &mut ModuleData| { &mut m.plug },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "atIndex",
                |m: &ModuleData| { &m.atIndex },
                |m: &mut ModuleData| { &mut m.atIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "board",
                |m: &ModuleData| { &m.board },
                |m: &mut ModuleData| { &mut m.board },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "boardAddr",
                |m: &ModuleData| { &m.boardAddr },
                |m: &mut ModuleData| { &mut m.boardAddr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModuleData>(
                "ModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModuleData {
        static instance: ::protobuf::rt::LazyV2<ModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModuleData::new)
    }
}

impl ::protobuf::Clear for ModuleData {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.readCount = 0;
        self.boardVersion.clear();
        self.plug = false;
        self.atIndex = 0;
        self.board.clear();
        self.boardAddr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct THLModuleData {
    // message fields
    pub humidity: f32,
    pub airTemperature: f32,
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a THLModuleData {
    fn default() -> &'a THLModuleData {
        <THLModuleData as ::protobuf::Message>::default_instance()
    }
}

impl THLModuleData {
    pub fn new() -> THLModuleData {
        ::std::default::Default::default()
    }

    // float humidity = 2;


    pub fn get_humidity(&self) -> f32 {
        self.humidity
    }
    pub fn clear_humidity(&mut self) {
        self.humidity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_humidity(&mut self, v: f32) {
        self.humidity = v;
    }

    // float airTemperature = 3;


    pub fn get_airTemperature(&self) -> f32 {
        self.airTemperature
    }
    pub fn clear_airTemperature(&mut self) {
        self.airTemperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_airTemperature(&mut self, v: f32) {
        self.airTemperature = v;
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for THLModuleData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.humidity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.airTemperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.humidity != 0. {
            my_size += 5;
        }
        if self.airTemperature != 0. {
            my_size += 5;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.humidity != 0. {
            os.write_float(2, self.humidity)?;
        }
        if self.airTemperature != 0. {
            os.write_float(3, self.airTemperature)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> THLModuleData {
        THLModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "humidity",
                |m: &THLModuleData| { &m.humidity },
                |m: &mut THLModuleData| { &mut m.humidity },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "airTemperature",
                |m: &THLModuleData| { &m.airTemperature },
                |m: &mut THLModuleData| { &mut m.airTemperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &THLModuleData| { &m.timestamp },
                |m: &mut THLModuleData| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<THLModuleData>(
                "THLModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static THLModuleData {
        static instance: ::protobuf::rt::LazyV2<THLModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(THLModuleData::new)
    }
}

impl ::protobuf::Clear for THLModuleData {
    fn clear(&mut self) {
        self.humidity = 0.;
        self.airTemperature = 0.;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for THLModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for THLModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILModuleData {
    // message fields
    pub p0: i32,
    pub p1: i32,
    pub p2: i32,
    pub p3: i32,
    pub p4: i32,
    pub p5: i32,
    pub p6: i32,
    pub p7: i32,
    pub timestamp: i32,
    pub valuetype: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILModuleData {
    fn default() -> &'a SOILModuleData {
        <SOILModuleData as ::protobuf::Message>::default_instance()
    }
}

impl SOILModuleData {
    pub fn new() -> SOILModuleData {
        ::std::default::Default::default()
    }

    // int32 p0 = 1;


    pub fn get_p0(&self) -> i32 {
        self.p0
    }
    pub fn clear_p0(&mut self) {
        self.p0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: i32) {
        self.p0 = v;
    }

    // int32 p1 = 2;


    pub fn get_p1(&self) -> i32 {
        self.p1
    }
    pub fn clear_p1(&mut self) {
        self.p1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: i32) {
        self.p1 = v;
    }

    // int32 p2 = 3;


    pub fn get_p2(&self) -> i32 {
        self.p2
    }
    pub fn clear_p2(&mut self) {
        self.p2 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: i32) {
        self.p2 = v;
    }

    // int32 p3 = 4;


    pub fn get_p3(&self) -> i32 {
        self.p3
    }
    pub fn clear_p3(&mut self) {
        self.p3 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p3(&mut self, v: i32) {
        self.p3 = v;
    }

    // int32 p4 = 5;


    pub fn get_p4(&self) -> i32 {
        self.p4
    }
    pub fn clear_p4(&mut self) {
        self.p4 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p4(&mut self, v: i32) {
        self.p4 = v;
    }

    // int32 p5 = 6;


    pub fn get_p5(&self) -> i32 {
        self.p5
    }
    pub fn clear_p5(&mut self) {
        self.p5 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p5(&mut self, v: i32) {
        self.p5 = v;
    }

    // int32 p6 = 7;


    pub fn get_p6(&self) -> i32 {
        self.p6
    }
    pub fn clear_p6(&mut self) {
        self.p6 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p6(&mut self, v: i32) {
        self.p6 = v;
    }

    // int32 p7 = 8;


    pub fn get_p7(&self) -> i32 {
        self.p7
    }
    pub fn clear_p7(&mut self) {
        self.p7 = 0;
    }

    // Param is passed by value, moved
    pub fn set_p7(&mut self, v: i32) {
        self.p7 = v;
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }

    // string valuetype = 10;


    pub fn get_valuetype(&self) -> &str {
        &self.valuetype
    }
    pub fn clear_valuetype(&mut self) {
        self.valuetype.clear();
    }

    // Param is passed by value, moved
    pub fn set_valuetype(&mut self, v: ::std::string::String) {
        self.valuetype = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valuetype(&mut self) -> &mut ::std::string::String {
        &mut self.valuetype
    }

    // Take field
    pub fn take_valuetype(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.valuetype, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SOILModuleData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p0 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p1 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p2 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p3 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p4 = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p5 = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p6 = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.p7 = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.valuetype)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.p0 != 0 {
            my_size += ::protobuf::rt::value_size(1, self.p0, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p1 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.p1, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p2 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.p2, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p3 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.p3, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p4 != 0 {
            my_size += ::protobuf::rt::value_size(5, self.p4, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p5 != 0 {
            my_size += ::protobuf::rt::value_size(6, self.p5, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p6 != 0 {
            my_size += ::protobuf::rt::value_size(7, self.p6, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.p7 != 0 {
            my_size += ::protobuf::rt::value_size(8, self.p7, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.valuetype.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.valuetype);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.p0 != 0 {
            os.write_int32(1, self.p0)?;
        }
        if self.p1 != 0 {
            os.write_int32(2, self.p1)?;
        }
        if self.p2 != 0 {
            os.write_int32(3, self.p2)?;
        }
        if self.p3 != 0 {
            os.write_int32(4, self.p3)?;
        }
        if self.p4 != 0 {
            os.write_int32(5, self.p4)?;
        }
        if self.p5 != 0 {
            os.write_int32(6, self.p5)?;
        }
        if self.p6 != 0 {
            os.write_int32(7, self.p6)?;
        }
        if self.p7 != 0 {
            os.write_int32(8, self.p7)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        if !self.valuetype.is_empty() {
            os.write_string(10, &self.valuetype)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILModuleData {
        SOILModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p0",
                |m: &SOILModuleData| { &m.p0 },
                |m: &mut SOILModuleData| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p1",
                |m: &SOILModuleData| { &m.p1 },
                |m: &mut SOILModuleData| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p2",
                |m: &SOILModuleData| { &m.p2 },
                |m: &mut SOILModuleData| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p3",
                |m: &SOILModuleData| { &m.p3 },
                |m: &mut SOILModuleData| { &mut m.p3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p4",
                |m: &SOILModuleData| { &m.p4 },
                |m: &mut SOILModuleData| { &mut m.p4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p5",
                |m: &SOILModuleData| { &m.p5 },
                |m: &mut SOILModuleData| { &mut m.p5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p6",
                |m: &SOILModuleData| { &m.p6 },
                |m: &mut SOILModuleData| { &mut m.p6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "p7",
                |m: &SOILModuleData| { &m.p7 },
                |m: &mut SOILModuleData| { &mut m.p7 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &SOILModuleData| { &m.timestamp },
                |m: &mut SOILModuleData| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "valuetype",
                |m: &SOILModuleData| { &m.valuetype },
                |m: &mut SOILModuleData| { &mut m.valuetype },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILModuleData>(
                "SOILModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILModuleData {
        static instance: ::protobuf::rt::LazyV2<SOILModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILModuleData::new)
    }
}

impl ::protobuf::Clear for SOILModuleData {
    fn clear(&mut self) {
        self.p0 = 0;
        self.p1 = 0;
        self.p2 = 0;
        self.p3 = 0;
        self.p4 = 0;
        self.p5 = 0;
        self.p6 = 0;
        self.p7 = 0;
        self.timestamp = 0;
        self.valuetype.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILProbeConfig {
    // message fields
    pub low: i32,
    pub high: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILProbeConfig {
    fn default() -> &'a SOILProbeConfig {
        <SOILProbeConfig as ::protobuf::Message>::default_instance()
    }
}

impl SOILProbeConfig {
    pub fn new() -> SOILProbeConfig {
        ::std::default::Default::default()
    }

    // int32 low = 1;


    pub fn get_low(&self) -> i32 {
        self.low
    }
    pub fn clear_low(&mut self) {
        self.low = 0;
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: i32) {
        self.low = v;
    }

    // int32 high = 2;


    pub fn get_high(&self) -> i32 {
        self.high
    }
    pub fn clear_high(&mut self) {
        self.high = 0;
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: i32) {
        self.high = v;
    }
}

impl ::protobuf::Message for SOILProbeConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.low = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.high = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.low != 0 {
            my_size += ::protobuf::rt::value_size(1, self.low, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.high != 0 {
            my_size += ::protobuf::rt::value_size(2, self.high, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.low != 0 {
            os.write_int32(1, self.low)?;
        }
        if self.high != 0 {
            os.write_int32(2, self.high)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILProbeConfig {
        SOILProbeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "low",
                |m: &SOILProbeConfig| { &m.low },
                |m: &mut SOILProbeConfig| { &mut m.low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "high",
                |m: &SOILProbeConfig| { &m.high },
                |m: &mut SOILProbeConfig| { &mut m.high },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILProbeConfig>(
                "SOILProbeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILProbeConfig {
        static instance: ::protobuf::rt::LazyV2<SOILProbeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILProbeConfig::new)
    }
}

impl ::protobuf::Clear for SOILProbeConfig {
    fn clear(&mut self) {
        self.low = 0;
        self.high = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILProbeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILProbeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILModuleConfig {
    // message fields
    pub p0: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p1: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p2: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p3: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p4: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p5: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p6: ::protobuf::SingularPtrField<SOILProbeConfig>,
    pub p7: ::protobuf::SingularPtrField<SOILProbeConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILModuleConfig {
    fn default() -> &'a SOILModuleConfig {
        <SOILModuleConfig as ::protobuf::Message>::default_instance()
    }
}

impl SOILModuleConfig {
    pub fn new() -> SOILModuleConfig {
        ::std::default::Default::default()
    }

    // .SOILProbeConfig p0 = 1;


    pub fn get_p0(&self) -> &SOILProbeConfig {
        self.p0.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: SOILProbeConfig) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut SOILProbeConfig {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> SOILProbeConfig {
        self.p0.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p1 = 2;


    pub fn get_p1(&self) -> &SOILProbeConfig {
        self.p1.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: SOILProbeConfig) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut SOILProbeConfig {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> SOILProbeConfig {
        self.p1.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p2 = 3;


    pub fn get_p2(&self) -> &SOILProbeConfig {
        self.p2.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: SOILProbeConfig) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut SOILProbeConfig {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> SOILProbeConfig {
        self.p2.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p3 = 4;


    pub fn get_p3(&self) -> &SOILProbeConfig {
        self.p3.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p3(&mut self) {
        self.p3.clear();
    }

    pub fn has_p3(&self) -> bool {
        self.p3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p3(&mut self, v: SOILProbeConfig) {
        self.p3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p3(&mut self) -> &mut SOILProbeConfig {
        if self.p3.is_none() {
            self.p3.set_default();
        }
        self.p3.as_mut().unwrap()
    }

    // Take field
    pub fn take_p3(&mut self) -> SOILProbeConfig {
        self.p3.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p4 = 5;


    pub fn get_p4(&self) -> &SOILProbeConfig {
        self.p4.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p4(&mut self) {
        self.p4.clear();
    }

    pub fn has_p4(&self) -> bool {
        self.p4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p4(&mut self, v: SOILProbeConfig) {
        self.p4 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4(&mut self) -> &mut SOILProbeConfig {
        if self.p4.is_none() {
            self.p4.set_default();
        }
        self.p4.as_mut().unwrap()
    }

    // Take field
    pub fn take_p4(&mut self) -> SOILProbeConfig {
        self.p4.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p5 = 6;


    pub fn get_p5(&self) -> &SOILProbeConfig {
        self.p5.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p5(&mut self) {
        self.p5.clear();
    }

    pub fn has_p5(&self) -> bool {
        self.p5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p5(&mut self, v: SOILProbeConfig) {
        self.p5 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p5(&mut self) -> &mut SOILProbeConfig {
        if self.p5.is_none() {
            self.p5.set_default();
        }
        self.p5.as_mut().unwrap()
    }

    // Take field
    pub fn take_p5(&mut self) -> SOILProbeConfig {
        self.p5.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p6 = 7;


    pub fn get_p6(&self) -> &SOILProbeConfig {
        self.p6.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p6(&mut self) {
        self.p6.clear();
    }

    pub fn has_p6(&self) -> bool {
        self.p6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p6(&mut self, v: SOILProbeConfig) {
        self.p6 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p6(&mut self) -> &mut SOILProbeConfig {
        if self.p6.is_none() {
            self.p6.set_default();
        }
        self.p6.as_mut().unwrap()
    }

    // Take field
    pub fn take_p6(&mut self) -> SOILProbeConfig {
        self.p6.take().unwrap_or_else(|| SOILProbeConfig::new())
    }

    // .SOILProbeConfig p7 = 8;


    pub fn get_p7(&self) -> &SOILProbeConfig {
        self.p7.as_ref().unwrap_or_else(|| <SOILProbeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p7(&mut self) {
        self.p7.clear();
    }

    pub fn has_p7(&self) -> bool {
        self.p7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p7(&mut self, v: SOILProbeConfig) {
        self.p7 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p7(&mut self) -> &mut SOILProbeConfig {
        if self.p7.is_none() {
            self.p7.set_default();
        }
        self.p7.as_mut().unwrap()
    }

    // Take field
    pub fn take_p7(&mut self) -> SOILProbeConfig {
        self.p7.take().unwrap_or_else(|| SOILProbeConfig::new())
    }
}

impl ::protobuf::Message for SOILModuleConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p4 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p5 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p6 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p7 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p3)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p4)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p5)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p6)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p7)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p5.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p7.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p3.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p4.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p5.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p6.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p7.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILModuleConfig {
        SOILModuleConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p0",
                |m: &SOILModuleConfig| { &m.p0 },
                |m: &mut SOILModuleConfig| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p1",
                |m: &SOILModuleConfig| { &m.p1 },
                |m: &mut SOILModuleConfig| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p2",
                |m: &SOILModuleConfig| { &m.p2 },
                |m: &mut SOILModuleConfig| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p3",
                |m: &SOILModuleConfig| { &m.p3 },
                |m: &mut SOILModuleConfig| { &mut m.p3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p4",
                |m: &SOILModuleConfig| { &m.p4 },
                |m: &mut SOILModuleConfig| { &mut m.p4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p5",
                |m: &SOILModuleConfig| { &m.p5 },
                |m: &mut SOILModuleConfig| { &mut m.p5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p6",
                |m: &SOILModuleConfig| { &m.p6 },
                |m: &mut SOILModuleConfig| { &mut m.p6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILProbeConfig>>(
                "p7",
                |m: &SOILModuleConfig| { &m.p7 },
                |m: &mut SOILModuleConfig| { &mut m.p7 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILModuleConfig>(
                "SOILModuleConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILModuleConfig {
        static instance: ::protobuf::rt::LazyV2<SOILModuleConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILModuleConfig::new)
    }
}

impl ::protobuf::Clear for SOILModuleConfig {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.p2.clear();
        self.p3.clear();
        self.p4.clear();
        self.p5.clear();
        self.p6.clear();
        self.p7.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILModuleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILModuleConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILCalibrationStart {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILCalibrationStart {
    fn default() -> &'a SOILCalibrationStart {
        <SOILCalibrationStart as ::protobuf::Message>::default_instance()
    }
}

impl SOILCalibrationStart {
    pub fn new() -> SOILCalibrationStart {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SOILCalibrationStart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILCalibrationStart {
        SOILCalibrationStart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILCalibrationStart>(
                "SOILCalibrationStart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILCalibrationStart {
        static instance: ::protobuf::rt::LazyV2<SOILCalibrationStart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILCalibrationStart::new)
    }
}

impl ::protobuf::Clear for SOILCalibrationStart {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILCalibrationStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILCalibrationStart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILCalibrationStep {
    // message fields
    pub requested_step: CalibrationStep,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILCalibrationStep {
    fn default() -> &'a SOILCalibrationStep {
        <SOILCalibrationStep as ::protobuf::Message>::default_instance()
    }
}

impl SOILCalibrationStep {
    pub fn new() -> SOILCalibrationStep {
        ::std::default::Default::default()
    }

    // .CalibrationStep requested_step = 1;


    pub fn get_requested_step(&self) -> CalibrationStep {
        self.requested_step
    }
    pub fn clear_requested_step(&mut self) {
        self.requested_step = CalibrationStep::READY_CALIBRATION;
    }

    // Param is passed by value, moved
    pub fn set_requested_step(&mut self, v: CalibrationStep) {
        self.requested_step = v;
    }
}

impl ::protobuf::Message for SOILCalibrationStep {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requested_step, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requested_step != CalibrationStep::READY_CALIBRATION {
            my_size += ::protobuf::rt::enum_size(1, self.requested_step);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requested_step != CalibrationStep::READY_CALIBRATION {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.requested_step))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILCalibrationStep {
        SOILCalibrationStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalibrationStep>>(
                "requested_step",
                |m: &SOILCalibrationStep| { &m.requested_step },
                |m: &mut SOILCalibrationStep| { &mut m.requested_step },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILCalibrationStep>(
                "SOILCalibrationStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILCalibrationStep {
        static instance: ::protobuf::rt::LazyV2<SOILCalibrationStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILCalibrationStep::new)
    }
}

impl ::protobuf::Clear for SOILCalibrationStep {
    fn clear(&mut self) {
        self.requested_step = CalibrationStep::READY_CALIBRATION;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILCalibrationStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILCalibrationStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SOILCalibrationStepEvent {
    // message fields
    pub step: CalibrationStep,
    pub status: CalibrationStepStatus,
    pub erro: CalibrationError,
    pub messag: ::std::string::String,
    pub low: ::protobuf::RepeatedField<SOILModuleData>,
    pub high: ::protobuf::RepeatedField<SOILModuleData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SOILCalibrationStepEvent {
    fn default() -> &'a SOILCalibrationStepEvent {
        <SOILCalibrationStepEvent as ::protobuf::Message>::default_instance()
    }
}

impl SOILCalibrationStepEvent {
    pub fn new() -> SOILCalibrationStepEvent {
        ::std::default::Default::default()
    }

    // .CalibrationStep step = 1;


    pub fn get_step(&self) -> CalibrationStep {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = CalibrationStep::READY_CALIBRATION;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: CalibrationStep) {
        self.step = v;
    }

    // .CalibrationStepStatus status = 2;


    pub fn get_status(&self) -> CalibrationStepStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = CalibrationStepStatus::INSUFFISANT_DATA_STATUS;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CalibrationStepStatus) {
        self.status = v;
    }

    // .CalibrationError erro = 3;


    pub fn get_erro(&self) -> CalibrationError {
        self.erro
    }
    pub fn clear_erro(&mut self) {
        self.erro = CalibrationError::NONE_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_erro(&mut self, v: CalibrationError) {
        self.erro = v;
    }

    // string messag = 4;


    pub fn get_messag(&self) -> &str {
        &self.messag
    }
    pub fn clear_messag(&mut self) {
        self.messag.clear();
    }

    // Param is passed by value, moved
    pub fn set_messag(&mut self, v: ::std::string::String) {
        self.messag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messag(&mut self) -> &mut ::std::string::String {
        &mut self.messag
    }

    // Take field
    pub fn take_messag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.messag, ::std::string::String::new())
    }

    // repeated .SOILModuleData low = 5;


    pub fn get_low(&self) -> &[SOILModuleData] {
        &self.low
    }
    pub fn clear_low(&mut self) {
        self.low.clear();
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: ::protobuf::RepeatedField<SOILModuleData>) {
        self.low = v;
    }

    // Mutable pointer to the field.
    pub fn mut_low(&mut self) -> &mut ::protobuf::RepeatedField<SOILModuleData> {
        &mut self.low
    }

    // Take field
    pub fn take_low(&mut self) -> ::protobuf::RepeatedField<SOILModuleData> {
        ::std::mem::replace(&mut self.low, ::protobuf::RepeatedField::new())
    }

    // repeated .SOILModuleData high = 6;


    pub fn get_high(&self) -> &[SOILModuleData] {
        &self.high
    }
    pub fn clear_high(&mut self) {
        self.high.clear();
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: ::protobuf::RepeatedField<SOILModuleData>) {
        self.high = v;
    }

    // Mutable pointer to the field.
    pub fn mut_high(&mut self) -> &mut ::protobuf::RepeatedField<SOILModuleData> {
        &mut self.high
    }

    // Take field
    pub fn take_high(&mut self) -> ::protobuf::RepeatedField<SOILModuleData> {
        ::std::mem::replace(&mut self.high, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SOILCalibrationStepEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.low {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.high {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.step, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.erro, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.messag)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.low)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.high)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.step != CalibrationStep::READY_CALIBRATION {
            my_size += ::protobuf::rt::enum_size(1, self.step);
        }
        if self.status != CalibrationStepStatus::INSUFFISANT_DATA_STATUS {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        if self.erro != CalibrationError::NONE_ERROR {
            my_size += ::protobuf::rt::enum_size(3, self.erro);
        }
        if !self.messag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.messag);
        }
        for value in &self.low {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.high {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.step != CalibrationStep::READY_CALIBRATION {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.step))?;
        }
        if self.status != CalibrationStepStatus::INSUFFISANT_DATA_STATUS {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.erro != CalibrationError::NONE_ERROR {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.erro))?;
        }
        if !self.messag.is_empty() {
            os.write_string(4, &self.messag)?;
        }
        for v in &self.low {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.high {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SOILCalibrationStepEvent {
        SOILCalibrationStepEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalibrationStep>>(
                "step",
                |m: &SOILCalibrationStepEvent| { &m.step },
                |m: &mut SOILCalibrationStepEvent| { &mut m.step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalibrationStepStatus>>(
                "status",
                |m: &SOILCalibrationStepEvent| { &m.status },
                |m: &mut SOILCalibrationStepEvent| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CalibrationError>>(
                "erro",
                |m: &SOILCalibrationStepEvent| { &m.erro },
                |m: &mut SOILCalibrationStepEvent| { &mut m.erro },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "messag",
                |m: &SOILCalibrationStepEvent| { &m.messag },
                |m: &mut SOILCalibrationStepEvent| { &mut m.messag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILModuleData>>(
                "low",
                |m: &SOILCalibrationStepEvent| { &m.low },
                |m: &mut SOILCalibrationStepEvent| { &mut m.low },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SOILModuleData>>(
                "high",
                |m: &SOILCalibrationStepEvent| { &m.high },
                |m: &mut SOILCalibrationStepEvent| { &mut m.high },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SOILCalibrationStepEvent>(
                "SOILCalibrationStepEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SOILCalibrationStepEvent {
        static instance: ::protobuf::rt::LazyV2<SOILCalibrationStepEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SOILCalibrationStepEvent::new)
    }
}

impl ::protobuf::Clear for SOILCalibrationStepEvent {
    fn clear(&mut self) {
        self.step = CalibrationStep::READY_CALIBRATION;
        self.status = CalibrationStepStatus::INSUFFISANT_DATA_STATUS;
        self.erro = CalibrationError::NONE_ERROR;
        self.messag.clear();
        self.low.clear();
        self.high.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SOILCalibrationStepEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SOILCalibrationStepEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WAModuleData {
    // message fields
    pub PH: i32,
    pub EC: i32,
    pub temperature: i32,
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WAModuleData {
    fn default() -> &'a WAModuleData {
        <WAModuleData as ::protobuf::Message>::default_instance()
    }
}

impl WAModuleData {
    pub fn new() -> WAModuleData {
        ::std::default::Default::default()
    }

    // int32 PH = 2;


    pub fn get_PH(&self) -> i32 {
        self.PH
    }
    pub fn clear_PH(&mut self) {
        self.PH = 0;
    }

    // Param is passed by value, moved
    pub fn set_PH(&mut self, v: i32) {
        self.PH = v;
    }

    // int32 EC = 3;


    pub fn get_EC(&self) -> i32 {
        self.EC
    }
    pub fn clear_EC(&mut self) {
        self.EC = 0;
    }

    // Param is passed by value, moved
    pub fn set_EC(&mut self, v: i32) {
        self.EC = v;
    }

    // int32 temperature = 4;


    pub fn get_temperature(&self) -> i32 {
        self.temperature
    }
    pub fn clear_temperature(&mut self) {
        self.temperature = 0;
    }

    // Param is passed by value, moved
    pub fn set_temperature(&mut self, v: i32) {
        self.temperature = v;
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for WAModuleData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.PH = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.EC = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.temperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.PH != 0 {
            my_size += ::protobuf::rt::value_size(2, self.PH, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EC != 0 {
            my_size += ::protobuf::rt::value_size(3, self.EC, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.temperature != 0 {
            my_size += ::protobuf::rt::value_size(4, self.temperature, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.PH != 0 {
            os.write_int32(2, self.PH)?;
        }
        if self.EC != 0 {
            os.write_int32(3, self.EC)?;
        }
        if self.temperature != 0 {
            os.write_int32(4, self.temperature)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WAModuleData {
        WAModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "PH",
                |m: &WAModuleData| { &m.PH },
                |m: &mut WAModuleData| { &mut m.PH },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "EC",
                |m: &WAModuleData| { &m.EC },
                |m: &mut WAModuleData| { &mut m.EC },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "temperature",
                |m: &WAModuleData| { &m.temperature },
                |m: &mut WAModuleData| { &mut m.temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &WAModuleData| { &m.timestamp },
                |m: &mut WAModuleData| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WAModuleData>(
                "WAModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WAModuleData {
        static instance: ::protobuf::rt::LazyV2<WAModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WAModuleData::new)
    }
}

impl ::protobuf::Clear for WAModuleData {
    fn clear(&mut self) {
        self.PH = 0;
        self.EC = 0;
        self.temperature = 0;
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WAModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WAModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CronItem {
    // message fields
    pub minute: i32,
    pub hour: i32,
    pub dayMonth: i32,
    pub month: i32,
    pub dayWeek: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CronItem {
    fn default() -> &'a CronItem {
        <CronItem as ::protobuf::Message>::default_instance()
    }
}

impl CronItem {
    pub fn new() -> CronItem {
        ::std::default::Default::default()
    }

    // int32 minute = 1;


    pub fn get_minute(&self) -> i32 {
        self.minute
    }
    pub fn clear_minute(&mut self) {
        self.minute = 0;
    }

    // Param is passed by value, moved
    pub fn set_minute(&mut self, v: i32) {
        self.minute = v;
    }

    // int32 hour = 2;


    pub fn get_hour(&self) -> i32 {
        self.hour
    }
    pub fn clear_hour(&mut self) {
        self.hour = 0;
    }

    // Param is passed by value, moved
    pub fn set_hour(&mut self, v: i32) {
        self.hour = v;
    }

    // int32 dayMonth = 3;


    pub fn get_dayMonth(&self) -> i32 {
        self.dayMonth
    }
    pub fn clear_dayMonth(&mut self) {
        self.dayMonth = 0;
    }

    // Param is passed by value, moved
    pub fn set_dayMonth(&mut self, v: i32) {
        self.dayMonth = v;
    }

    // int32 month = 4;


    pub fn get_month(&self) -> i32 {
        self.month
    }
    pub fn clear_month(&mut self) {
        self.month = 0;
    }

    // Param is passed by value, moved
    pub fn set_month(&mut self, v: i32) {
        self.month = v;
    }

    // int32 dayWeek = 5;


    pub fn get_dayWeek(&self) -> i32 {
        self.dayWeek
    }
    pub fn clear_dayWeek(&mut self) {
        self.dayWeek = 0;
    }

    // Param is passed by value, moved
    pub fn set_dayWeek(&mut self, v: i32) {
        self.dayWeek = v;
    }
}

impl ::protobuf::Message for CronItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minute = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hour = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dayMonth = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.month = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dayWeek = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.minute != 0 {
            my_size += ::protobuf::rt::value_size(1, self.minute, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.hour != 0 {
            my_size += ::protobuf::rt::value_size(2, self.hour, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dayMonth != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dayMonth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.month != 0 {
            my_size += ::protobuf::rt::value_size(4, self.month, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dayWeek != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dayWeek, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.minute != 0 {
            os.write_int32(1, self.minute)?;
        }
        if self.hour != 0 {
            os.write_int32(2, self.hour)?;
        }
        if self.dayMonth != 0 {
            os.write_int32(3, self.dayMonth)?;
        }
        if self.month != 0 {
            os.write_int32(4, self.month)?;
        }
        if self.dayWeek != 0 {
            os.write_int32(5, self.dayWeek)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CronItem {
        CronItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minute",
                |m: &CronItem| { &m.minute },
                |m: &mut CronItem| { &mut m.minute },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "hour",
                |m: &CronItem| { &m.hour },
                |m: &mut CronItem| { &mut m.hour },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dayMonth",
                |m: &CronItem| { &m.dayMonth },
                |m: &mut CronItem| { &mut m.dayMonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "month",
                |m: &CronItem| { &m.month },
                |m: &mut CronItem| { &mut m.month },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dayWeek",
                |m: &CronItem| { &m.dayWeek },
                |m: &mut CronItem| { &mut m.dayWeek },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CronItem>(
                "CronItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CronItem {
        static instance: ::protobuf::rt::LazyV2<CronItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CronItem::new)
    }
}

impl ::protobuf::Clear for CronItem {
    fn clear(&mut self) {
        self.minute = 0;
        self.hour = 0;
        self.dayMonth = 0;
        self.month = 0;
        self.dayWeek = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CronItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CronItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CycleConfig {
    // message fields
    pub waitingTime: i32,
    pub runningTime: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CycleConfig {
    fn default() -> &'a CycleConfig {
        <CycleConfig as ::protobuf::Message>::default_instance()
    }
}

impl CycleConfig {
    pub fn new() -> CycleConfig {
        ::std::default::Default::default()
    }

    // int32 waitingTime = 1;


    pub fn get_waitingTime(&self) -> i32 {
        self.waitingTime
    }
    pub fn clear_waitingTime(&mut self) {
        self.waitingTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_waitingTime(&mut self, v: i32) {
        self.waitingTime = v;
    }

    // int32 runningTime = 2;


    pub fn get_runningTime(&self) -> i32 {
        self.runningTime
    }
    pub fn clear_runningTime(&mut self) {
        self.runningTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_runningTime(&mut self, v: i32) {
        self.runningTime = v;
    }
}

impl ::protobuf::Message for CycleConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.waitingTime = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.runningTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.waitingTime != 0 {
            my_size += ::protobuf::rt::value_size(1, self.waitingTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.runningTime != 0 {
            my_size += ::protobuf::rt::value_size(2, self.runningTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.waitingTime != 0 {
            os.write_int32(1, self.waitingTime)?;
        }
        if self.runningTime != 0 {
            os.write_int32(2, self.runningTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CycleConfig {
        CycleConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "waitingTime",
                |m: &CycleConfig| { &m.waitingTime },
                |m: &mut CycleConfig| { &mut m.waitingTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "runningTime",
                |m: &CycleConfig| { &m.runningTime },
                |m: &mut CycleConfig| { &mut m.runningTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CycleConfig>(
                "CycleConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CycleConfig {
        static instance: ::protobuf::rt::LazyV2<CycleConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CycleConfig::new)
    }
}

impl ::protobuf::Clear for CycleConfig {
    fn clear(&mut self) {
        self.waitingTime = 0;
        self.runningTime = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CycleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CycleConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AlarmConfig {
    // message fields
    pub begining: ::protobuf::SingularPtrField<CronItem>,
    pub end: ::protobuf::SingularPtrField<CronItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AlarmConfig {
    fn default() -> &'a AlarmConfig {
        <AlarmConfig as ::protobuf::Message>::default_instance()
    }
}

impl AlarmConfig {
    pub fn new() -> AlarmConfig {
        ::std::default::Default::default()
    }

    // .CronItem begining = 1;


    pub fn get_begining(&self) -> &CronItem {
        self.begining.as_ref().unwrap_or_else(|| <CronItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_begining(&mut self) {
        self.begining.clear();
    }

    pub fn has_begining(&self) -> bool {
        self.begining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begining(&mut self, v: CronItem) {
        self.begining = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_begining(&mut self) -> &mut CronItem {
        if self.begining.is_none() {
            self.begining.set_default();
        }
        self.begining.as_mut().unwrap()
    }

    // Take field
    pub fn take_begining(&mut self) -> CronItem {
        self.begining.take().unwrap_or_else(|| CronItem::new())
    }

    // .CronItem end = 2;


    pub fn get_end(&self) -> &CronItem {
        self.end.as_ref().unwrap_or_else(|| <CronItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: CronItem) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut CronItem {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> CronItem {
        self.end.take().unwrap_or_else(|| CronItem::new())
    }
}

impl ::protobuf::Message for AlarmConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.begining {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.begining)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.begining.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.begining.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AlarmConfig {
        AlarmConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CronItem>>(
                "begining",
                |m: &AlarmConfig| { &m.begining },
                |m: &mut AlarmConfig| { &mut m.begining },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CronItem>>(
                "end",
                |m: &AlarmConfig| { &m.end },
                |m: &mut AlarmConfig| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AlarmConfig>(
                "AlarmConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AlarmConfig {
        static instance: ::protobuf::rt::LazyV2<AlarmConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AlarmConfig::new)
    }
}

impl ::protobuf::Clear for AlarmConfig {
    fn clear(&mut self) {
        self.begining.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AlarmConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ManualConfig {
    // message fields
    pub state: bool,
    pub duration: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ManualConfig {
    fn default() -> &'a ManualConfig {
        <ManualConfig as ::protobuf::Message>::default_instance()
    }
}

impl ManualConfig {
    pub fn new() -> ManualConfig {
        ::std::default::Default::default()
    }

    // bool state = 1;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // int32 duration = 2;


    pub fn get_duration(&self) -> i32 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = v;
    }
}

impl ::protobuf::Message for ManualConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != false {
            my_size += 2;
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(2, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != false {
            os.write_bool(1, self.state)?;
        }
        if self.duration != 0 {
            os.write_int32(2, self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ManualConfig {
        ManualConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &ManualConfig| { &m.state },
                |m: &mut ManualConfig| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "duration",
                |m: &ManualConfig| { &m.duration },
                |m: &mut ManualConfig| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ManualConfig>(
                "ManualConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ManualConfig {
        static instance: ::protobuf::rt::LazyV2<ManualConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ManualConfig::new)
    }
}

impl ::protobuf::Clear for ManualConfig {
    fn clear(&mut self) {
        self.state = false;
        self.duration = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ManualConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManualConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayOutletData {
    // message fields
    pub state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayOutletData {
    fn default() -> &'a RelayOutletData {
        <RelayOutletData as ::protobuf::Message>::default_instance()
    }
}

impl RelayOutletData {
    pub fn new() -> RelayOutletData {
        ::std::default::Default::default()
    }

    // bool state = 1;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }
}

impl ::protobuf::Message for RelayOutletData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != false {
            os.write_bool(1, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayOutletData {
        RelayOutletData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &RelayOutletData| { &m.state },
                |m: &mut RelayOutletData| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayOutletData>(
                "RelayOutletData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayOutletData {
        static instance: ::protobuf::rt::LazyV2<RelayOutletData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayOutletData::new)
    }
}

impl ::protobuf::Clear for RelayOutletData {
    fn clear(&mut self) {
        self.state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayOutletData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayOutletData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelayConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelayConfig {
    fn default() -> &'a VirtualRelayConfig {
        <VirtualRelayConfig as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelayConfig {
    pub fn new() -> VirtualRelayConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VirtualRelayConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelayConfig {
        VirtualRelayConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelayConfig>(
                "VirtualRelayConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelayConfig {
        static instance: ::protobuf::rt::LazyV2<VirtualRelayConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelayConfig::new)
    }
}

impl ::protobuf::Clear for VirtualRelayConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelayConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelayConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayOutletConfig {
    // message fields
    pub mode: RelayOutletMode,
    pub alarm: ::protobuf::SingularPtrField<AlarmConfig>,
    pub manual: ::protobuf::SingularPtrField<ManualConfig>,
    pub field_virtual: ::protobuf::SingularPtrField<VirtualRelayConfig>,
    pub cycle: ::protobuf::SingularPtrField<CycleConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayOutletConfig {
    fn default() -> &'a RelayOutletConfig {
        <RelayOutletConfig as ::protobuf::Message>::default_instance()
    }
}

impl RelayOutletConfig {
    pub fn new() -> RelayOutletConfig {
        ::std::default::Default::default()
    }

    // .RelayOutletMode mode = 1;


    pub fn get_mode(&self) -> RelayOutletMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = RelayOutletMode::MANUAL;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: RelayOutletMode) {
        self.mode = v;
    }

    // .AlarmConfig alarm = 2;


    pub fn get_alarm(&self) -> &AlarmConfig {
        self.alarm.as_ref().unwrap_or_else(|| <AlarmConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_alarm(&mut self) {
        self.alarm.clear();
    }

    pub fn has_alarm(&self) -> bool {
        self.alarm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alarm(&mut self, v: AlarmConfig) {
        self.alarm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alarm(&mut self) -> &mut AlarmConfig {
        if self.alarm.is_none() {
            self.alarm.set_default();
        }
        self.alarm.as_mut().unwrap()
    }

    // Take field
    pub fn take_alarm(&mut self) -> AlarmConfig {
        self.alarm.take().unwrap_or_else(|| AlarmConfig::new())
    }

    // .ManualConfig manual = 3;


    pub fn get_manual(&self) -> &ManualConfig {
        self.manual.as_ref().unwrap_or_else(|| <ManualConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_manual(&mut self) {
        self.manual.clear();
    }

    pub fn has_manual(&self) -> bool {
        self.manual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manual(&mut self, v: ManualConfig) {
        self.manual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manual(&mut self) -> &mut ManualConfig {
        if self.manual.is_none() {
            self.manual.set_default();
        }
        self.manual.as_mut().unwrap()
    }

    // Take field
    pub fn take_manual(&mut self) -> ManualConfig {
        self.manual.take().unwrap_or_else(|| ManualConfig::new())
    }

    // .VirtualRelayConfig virtual = 4;


    pub fn get_field_virtual(&self) -> &VirtualRelayConfig {
        self.field_virtual.as_ref().unwrap_or_else(|| <VirtualRelayConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_virtual(&mut self) {
        self.field_virtual.clear();
    }

    pub fn has_field_virtual(&self) -> bool {
        self.field_virtual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_virtual(&mut self, v: VirtualRelayConfig) {
        self.field_virtual = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_virtual(&mut self) -> &mut VirtualRelayConfig {
        if self.field_virtual.is_none() {
            self.field_virtual.set_default();
        }
        self.field_virtual.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_virtual(&mut self) -> VirtualRelayConfig {
        self.field_virtual.take().unwrap_or_else(|| VirtualRelayConfig::new())
    }

    // .CycleConfig cycle = 5;


    pub fn get_cycle(&self) -> &CycleConfig {
        self.cycle.as_ref().unwrap_or_else(|| <CycleConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cycle(&mut self) {
        self.cycle.clear();
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: CycleConfig) {
        self.cycle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cycle(&mut self) -> &mut CycleConfig {
        if self.cycle.is_none() {
            self.cycle.set_default();
        }
        self.cycle.as_mut().unwrap()
    }

    // Take field
    pub fn take_cycle(&mut self) -> CycleConfig {
        self.cycle.take().unwrap_or_else(|| CycleConfig::new())
    }
}

impl ::protobuf::Message for RelayOutletConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.alarm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.manual {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_virtual {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cycle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.alarm)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.manual)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_virtual)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cycle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != RelayOutletMode::MANUAL {
            my_size += ::protobuf::rt::enum_size(1, self.mode);
        }
        if let Some(ref v) = self.alarm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.manual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_virtual.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mode != RelayOutletMode::MANUAL {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if let Some(ref v) = self.alarm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.manual.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_virtual.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cycle.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayOutletConfig {
        RelayOutletConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RelayOutletMode>>(
                "mode",
                |m: &RelayOutletConfig| { &m.mode },
                |m: &mut RelayOutletConfig| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AlarmConfig>>(
                "alarm",
                |m: &RelayOutletConfig| { &m.alarm },
                |m: &mut RelayOutletConfig| { &mut m.alarm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ManualConfig>>(
                "manual",
                |m: &RelayOutletConfig| { &m.manual },
                |m: &mut RelayOutletConfig| { &mut m.manual },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRelayConfig>>(
                "virtual",
                |m: &RelayOutletConfig| { &m.field_virtual },
                |m: &mut RelayOutletConfig| { &mut m.field_virtual },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CycleConfig>>(
                "cycle",
                |m: &RelayOutletConfig| { &m.cycle },
                |m: &mut RelayOutletConfig| { &mut m.cycle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayOutletConfig>(
                "RelayOutletConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayOutletConfig {
        static instance: ::protobuf::rt::LazyV2<RelayOutletConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayOutletConfig::new)
    }
}

impl ::protobuf::Clear for RelayOutletConfig {
    fn clear(&mut self) {
        self.mode = RelayOutletMode::MANUAL;
        self.alarm.clear();
        self.manual.clear();
        self.field_virtual.clear();
        self.cycle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayOutletConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayOutletConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelayPropertyConfig {
    // message fields
    pub property: i32,
    pub falseState: bool,
    pub trueState: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelayPropertyConfig {
    fn default() -> &'a VirtualRelayPropertyConfig {
        <VirtualRelayPropertyConfig as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelayPropertyConfig {
    pub fn new() -> VirtualRelayPropertyConfig {
        ::std::default::Default::default()
    }

    // int32 property = 1;


    pub fn get_property(&self) -> i32 {
        self.property
    }
    pub fn clear_property(&mut self) {
        self.property = 0;
    }

    // Param is passed by value, moved
    pub fn set_property(&mut self, v: i32) {
        self.property = v;
    }

    // bool falseState = 2;


    pub fn get_falseState(&self) -> bool {
        self.falseState
    }
    pub fn clear_falseState(&mut self) {
        self.falseState = false;
    }

    // Param is passed by value, moved
    pub fn set_falseState(&mut self, v: bool) {
        self.falseState = v;
    }

    // bool trueState = 3;


    pub fn get_trueState(&self) -> bool {
        self.trueState
    }
    pub fn clear_trueState(&mut self) {
        self.trueState = false;
    }

    // Param is passed by value, moved
    pub fn set_trueState(&mut self, v: bool) {
        self.trueState = v;
    }
}

impl ::protobuf::Message for VirtualRelayPropertyConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.falseState = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trueState = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.falseState != false {
            my_size += 2;
        }
        if self.trueState != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.property != 0 {
            os.write_int32(1, self.property)?;
        }
        if self.falseState != false {
            os.write_bool(2, self.falseState)?;
        }
        if self.trueState != false {
            os.write_bool(3, self.trueState)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelayPropertyConfig {
        VirtualRelayPropertyConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "property",
                |m: &VirtualRelayPropertyConfig| { &m.property },
                |m: &mut VirtualRelayPropertyConfig| { &mut m.property },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "falseState",
                |m: &VirtualRelayPropertyConfig| { &m.falseState },
                |m: &mut VirtualRelayPropertyConfig| { &mut m.falseState },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trueState",
                |m: &VirtualRelayPropertyConfig| { &m.trueState },
                |m: &mut VirtualRelayPropertyConfig| { &mut m.trueState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelayPropertyConfig>(
                "VirtualRelayPropertyConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelayPropertyConfig {
        static instance: ::protobuf::rt::LazyV2<VirtualRelayPropertyConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelayPropertyConfig::new)
    }
}

impl ::protobuf::Clear for VirtualRelayPropertyConfig {
    fn clear(&mut self) {
        self.property = 0;
        self.falseState = false;
        self.trueState = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelayPropertyConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelayPropertyConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelayItem {
    // message fields
    pub properties: ::protobuf::RepeatedField<VirtualRelayPropertyConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelayItem {
    fn default() -> &'a VirtualRelayItem {
        <VirtualRelayItem as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelayItem {
    pub fn new() -> VirtualRelayItem {
        ::std::default::Default::default()
    }

    // repeated .VirtualRelayPropertyConfig properties = 1;


    pub fn get_properties(&self) -> &[VirtualRelayPropertyConfig] {
        &self.properties
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<VirtualRelayPropertyConfig>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<VirtualRelayPropertyConfig> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<VirtualRelayPropertyConfig> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualRelayItem {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.properties {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelayItem {
        VirtualRelayItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRelayPropertyConfig>>(
                "properties",
                |m: &VirtualRelayItem| { &m.properties },
                |m: &mut VirtualRelayItem| { &mut m.properties },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelayItem>(
                "VirtualRelayItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelayItem {
        static instance: ::protobuf::rt::LazyV2<VirtualRelayItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelayItem::new)
    }
}

impl ::protobuf::Clear for VirtualRelayItem {
    fn clear(&mut self) {
        self.properties.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelayItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelayItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelay {
    // message fields
    pub name: ::std::string::String,
    pub relays: ::std::collections::HashMap<::std::string::String, VirtualRelayItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelay {
    fn default() -> &'a VirtualRelay {
        <VirtualRelay as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelay {
    pub fn new() -> VirtualRelay {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .VirtualRelay.RelaysEntry relays = 2;


    pub fn get_relays(&self) -> &::std::collections::HashMap<::std::string::String, VirtualRelayItem> {
        &self.relays
    }
    pub fn clear_relays(&mut self) {
        self.relays.clear();
    }

    // Param is passed by value, moved
    pub fn set_relays(&mut self, v: ::std::collections::HashMap<::std::string::String, VirtualRelayItem>) {
        self.relays = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relays(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, VirtualRelayItem> {
        &mut self.relays
    }

    // Take field
    pub fn take_relays(&mut self) -> ::std::collections::HashMap<::std::string::String, VirtualRelayItem> {
        ::std::mem::replace(&mut self.relays, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for VirtualRelay {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualRelayItem>>(wire_type, is, &mut self.relays)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualRelayItem>>(2, &self.relays);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualRelayItem>>(2, &self.relays, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelay {
        VirtualRelay::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VirtualRelay| { &m.name },
                |m: &mut VirtualRelay| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualRelayItem>>(
                "relays",
                |m: &VirtualRelay| { &m.relays },
                |m: &mut VirtualRelay| { &mut m.relays },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelay>(
                "VirtualRelay",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelay {
        static instance: ::protobuf::rt::LazyV2<VirtualRelay> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelay::new)
    }
}

impl ::protobuf::Clear for VirtualRelay {
    fn clear(&mut self) {
        self.name.clear();
        self.relays.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelay {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelays {
    // message fields
    pub relays: ::protobuf::RepeatedField<VirtualRelay>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelays {
    fn default() -> &'a VirtualRelays {
        <VirtualRelays as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelays {
    pub fn new() -> VirtualRelays {
        ::std::default::Default::default()
    }

    // repeated .VirtualRelay relays = 1;


    pub fn get_relays(&self) -> &[VirtualRelay] {
        &self.relays
    }
    pub fn clear_relays(&mut self) {
        self.relays.clear();
    }

    // Param is passed by value, moved
    pub fn set_relays(&mut self, v: ::protobuf::RepeatedField<VirtualRelay>) {
        self.relays = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relays(&mut self) -> &mut ::protobuf::RepeatedField<VirtualRelay> {
        &mut self.relays
    }

    // Take field
    pub fn take_relays(&mut self) -> ::protobuf::RepeatedField<VirtualRelay> {
        ::std::mem::replace(&mut self.relays, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualRelays {
    fn is_initialized(&self) -> bool {
        for v in &self.relays {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relays)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.relays {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.relays {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelays {
        VirtualRelays::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRelay>>(
                "relays",
                |m: &VirtualRelays| { &m.relays },
                |m: &mut VirtualRelays| { &mut m.relays },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelays>(
                "VirtualRelays",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelays {
        static instance: ::protobuf::rt::LazyV2<VirtualRelays> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelays::new)
    }
}

impl ::protobuf::Clear for VirtualRelays {
    fn clear(&mut self) {
        self.relays.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelays {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelayData {
    // message fields
    pub data: ::protobuf::SingularPtrField<RelayOutletData>,
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelayData {
    fn default() -> &'a VirtualRelayData {
        <VirtualRelayData as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelayData {
    pub fn new() -> VirtualRelayData {
        ::std::default::Default::default()
    }

    // .RelayOutletData data = 1;


    pub fn get_data(&self) -> &RelayOutletData {
        self.data.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: RelayOutletData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut RelayOutletData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> RelayOutletData {
        self.data.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // int32 timestamp = 2;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for VirtualRelayData {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_int32(2, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelayData {
        VirtualRelayData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "data",
                |m: &VirtualRelayData| { &m.data },
                |m: &mut VirtualRelayData| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &VirtualRelayData| { &m.timestamp },
                |m: &mut VirtualRelayData| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelayData>(
                "VirtualRelayData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelayData {
        static instance: ::protobuf::rt::LazyV2<VirtualRelayData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelayData::new)
    }
}

impl ::protobuf::Clear for VirtualRelayData {
    fn clear(&mut self) {
        self.data.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelayData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelayData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRelayState {
    // message fields
    pub id: ::std::string::String,
    pub state: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRelayState {
    fn default() -> &'a VirtualRelayState {
        <VirtualRelayState as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRelayState {
    pub fn new() -> VirtualRelayState {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VirtualRelayState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.state != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRelayState {
        VirtualRelayState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &VirtualRelayState| { &m.id },
                |m: &mut VirtualRelayState| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &VirtualRelayState| { &m.state },
                |m: &mut VirtualRelayState| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &VirtualRelayState| { &m.message },
                |m: &mut VirtualRelayState| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRelayState>(
                "VirtualRelayState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRelayState {
        static instance: ::protobuf::rt::LazyV2<VirtualRelayState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRelayState::new)
    }
}

impl ::protobuf::Clear for VirtualRelayState {
    fn clear(&mut self) {
        self.id.clear();
        self.state = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRelayState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRelayState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayModuleData {
    // message fields
    pub p0: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p1: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p2: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p3: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p4: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p5: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p6: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p7: ::protobuf::SingularPtrField<RelayOutletData>,
    pub timestamp: i32,
    pub actor: ::protobuf::SingularPtrField<Actor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayModuleData {
    fn default() -> &'a RelayModuleData {
        <RelayModuleData as ::protobuf::Message>::default_instance()
    }
}

impl RelayModuleData {
    pub fn new() -> RelayModuleData {
        ::std::default::Default::default()
    }

    // .RelayOutletData p0 = 1;


    pub fn get_p0(&self) -> &RelayOutletData {
        self.p0.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: RelayOutletData) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut RelayOutletData {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> RelayOutletData {
        self.p0.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p1 = 2;


    pub fn get_p1(&self) -> &RelayOutletData {
        self.p1.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: RelayOutletData) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut RelayOutletData {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> RelayOutletData {
        self.p1.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p2 = 3;


    pub fn get_p2(&self) -> &RelayOutletData {
        self.p2.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: RelayOutletData) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut RelayOutletData {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> RelayOutletData {
        self.p2.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p3 = 4;


    pub fn get_p3(&self) -> &RelayOutletData {
        self.p3.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p3(&mut self) {
        self.p3.clear();
    }

    pub fn has_p3(&self) -> bool {
        self.p3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p3(&mut self, v: RelayOutletData) {
        self.p3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p3(&mut self) -> &mut RelayOutletData {
        if self.p3.is_none() {
            self.p3.set_default();
        }
        self.p3.as_mut().unwrap()
    }

    // Take field
    pub fn take_p3(&mut self) -> RelayOutletData {
        self.p3.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p4 = 5;


    pub fn get_p4(&self) -> &RelayOutletData {
        self.p4.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p4(&mut self) {
        self.p4.clear();
    }

    pub fn has_p4(&self) -> bool {
        self.p4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p4(&mut self, v: RelayOutletData) {
        self.p4 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4(&mut self) -> &mut RelayOutletData {
        if self.p4.is_none() {
            self.p4.set_default();
        }
        self.p4.as_mut().unwrap()
    }

    // Take field
    pub fn take_p4(&mut self) -> RelayOutletData {
        self.p4.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p5 = 6;


    pub fn get_p5(&self) -> &RelayOutletData {
        self.p5.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p5(&mut self) {
        self.p5.clear();
    }

    pub fn has_p5(&self) -> bool {
        self.p5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p5(&mut self, v: RelayOutletData) {
        self.p5 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p5(&mut self) -> &mut RelayOutletData {
        if self.p5.is_none() {
            self.p5.set_default();
        }
        self.p5.as_mut().unwrap()
    }

    // Take field
    pub fn take_p5(&mut self) -> RelayOutletData {
        self.p5.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p6 = 7;


    pub fn get_p6(&self) -> &RelayOutletData {
        self.p6.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p6(&mut self) {
        self.p6.clear();
    }

    pub fn has_p6(&self) -> bool {
        self.p6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p6(&mut self, v: RelayOutletData) {
        self.p6 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p6(&mut self) -> &mut RelayOutletData {
        if self.p6.is_none() {
            self.p6.set_default();
        }
        self.p6.as_mut().unwrap()
    }

    // Take field
    pub fn take_p6(&mut self) -> RelayOutletData {
        self.p6.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p7 = 8;


    pub fn get_p7(&self) -> &RelayOutletData {
        self.p7.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p7(&mut self) {
        self.p7.clear();
    }

    pub fn has_p7(&self) -> bool {
        self.p7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p7(&mut self, v: RelayOutletData) {
        self.p7 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p7(&mut self) -> &mut RelayOutletData {
        if self.p7.is_none() {
            self.p7.set_default();
        }
        self.p7.as_mut().unwrap()
    }

    // Take field
    pub fn take_p7(&mut self) -> RelayOutletData {
        self.p7.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }

    // .Actor actor = 10;


    pub fn get_actor(&self) -> &Actor {
        self.actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: Actor) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut Actor {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> Actor {
        self.actor.take().unwrap_or_else(|| Actor::new())
    }
}

impl ::protobuf::Message for RelayModuleData {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p4 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p5 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p6 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p7 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p3)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p4)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p5)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p6)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p7)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p5.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p7.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p3.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p4.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p5.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p6.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p7.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayModuleData {
        RelayModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p0",
                |m: &RelayModuleData| { &m.p0 },
                |m: &mut RelayModuleData| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p1",
                |m: &RelayModuleData| { &m.p1 },
                |m: &mut RelayModuleData| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p2",
                |m: &RelayModuleData| { &m.p2 },
                |m: &mut RelayModuleData| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p3",
                |m: &RelayModuleData| { &m.p3 },
                |m: &mut RelayModuleData| { &mut m.p3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p4",
                |m: &RelayModuleData| { &m.p4 },
                |m: &mut RelayModuleData| { &mut m.p4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p5",
                |m: &RelayModuleData| { &m.p5 },
                |m: &mut RelayModuleData| { &mut m.p5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p6",
                |m: &RelayModuleData| { &m.p6 },
                |m: &mut RelayModuleData| { &mut m.p6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p7",
                |m: &RelayModuleData| { &m.p7 },
                |m: &mut RelayModuleData| { &mut m.p7 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &RelayModuleData| { &m.timestamp },
                |m: &mut RelayModuleData| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "actor",
                |m: &RelayModuleData| { &m.actor },
                |m: &mut RelayModuleData| { &mut m.actor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayModuleData>(
                "RelayModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayModuleData {
        static instance: ::protobuf::rt::LazyV2<RelayModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayModuleData::new)
    }
}

impl ::protobuf::Clear for RelayModuleData {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.p2.clear();
        self.p3.clear();
        self.p4.clear();
        self.p5.clear();
        self.p6.clear();
        self.p7.clear();
        self.timestamp = 0;
        self.actor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayModuleConfig {
    // message fields
    pub p0: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p1: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p2: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p3: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p4: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p5: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p6: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p7: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub timestamp: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayModuleConfig {
    fn default() -> &'a RelayModuleConfig {
        <RelayModuleConfig as ::protobuf::Message>::default_instance()
    }
}

impl RelayModuleConfig {
    pub fn new() -> RelayModuleConfig {
        ::std::default::Default::default()
    }

    // .RelayOutletConfig p0 = 1;


    pub fn get_p0(&self) -> &RelayOutletConfig {
        self.p0.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: RelayOutletConfig) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut RelayOutletConfig {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> RelayOutletConfig {
        self.p0.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p1 = 2;


    pub fn get_p1(&self) -> &RelayOutletConfig {
        self.p1.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: RelayOutletConfig) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut RelayOutletConfig {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> RelayOutletConfig {
        self.p1.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p2 = 3;


    pub fn get_p2(&self) -> &RelayOutletConfig {
        self.p2.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: RelayOutletConfig) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut RelayOutletConfig {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> RelayOutletConfig {
        self.p2.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p3 = 4;


    pub fn get_p3(&self) -> &RelayOutletConfig {
        self.p3.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p3(&mut self) {
        self.p3.clear();
    }

    pub fn has_p3(&self) -> bool {
        self.p3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p3(&mut self, v: RelayOutletConfig) {
        self.p3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p3(&mut self) -> &mut RelayOutletConfig {
        if self.p3.is_none() {
            self.p3.set_default();
        }
        self.p3.as_mut().unwrap()
    }

    // Take field
    pub fn take_p3(&mut self) -> RelayOutletConfig {
        self.p3.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p4 = 5;


    pub fn get_p4(&self) -> &RelayOutletConfig {
        self.p4.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p4(&mut self) {
        self.p4.clear();
    }

    pub fn has_p4(&self) -> bool {
        self.p4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p4(&mut self, v: RelayOutletConfig) {
        self.p4 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p4(&mut self) -> &mut RelayOutletConfig {
        if self.p4.is_none() {
            self.p4.set_default();
        }
        self.p4.as_mut().unwrap()
    }

    // Take field
    pub fn take_p4(&mut self) -> RelayOutletConfig {
        self.p4.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p5 = 6;


    pub fn get_p5(&self) -> &RelayOutletConfig {
        self.p5.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p5(&mut self) {
        self.p5.clear();
    }

    pub fn has_p5(&self) -> bool {
        self.p5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p5(&mut self, v: RelayOutletConfig) {
        self.p5 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p5(&mut self) -> &mut RelayOutletConfig {
        if self.p5.is_none() {
            self.p5.set_default();
        }
        self.p5.as_mut().unwrap()
    }

    // Take field
    pub fn take_p5(&mut self) -> RelayOutletConfig {
        self.p5.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p6 = 7;


    pub fn get_p6(&self) -> &RelayOutletConfig {
        self.p6.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p6(&mut self) {
        self.p6.clear();
    }

    pub fn has_p6(&self) -> bool {
        self.p6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p6(&mut self, v: RelayOutletConfig) {
        self.p6 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p6(&mut self) -> &mut RelayOutletConfig {
        if self.p6.is_none() {
            self.p6.set_default();
        }
        self.p6.as_mut().unwrap()
    }

    // Take field
    pub fn take_p6(&mut self) -> RelayOutletConfig {
        self.p6.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p7 = 8;


    pub fn get_p7(&self) -> &RelayOutletConfig {
        self.p7.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p7(&mut self) {
        self.p7.clear();
    }

    pub fn has_p7(&self) -> bool {
        self.p7.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p7(&mut self, v: RelayOutletConfig) {
        self.p7 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p7(&mut self) -> &mut RelayOutletConfig {
        if self.p7.is_none() {
            self.p7.set_default();
        }
        self.p7.as_mut().unwrap()
    }

    // Take field
    pub fn take_p7(&mut self) -> RelayOutletConfig {
        self.p7.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }
}

impl ::protobuf::Message for RelayModuleConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p4 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p5 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p6 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p7 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p3)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p4)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p5)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p6)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p7)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p4.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p5.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p7.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p3.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p4.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p5.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p6.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p7.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayModuleConfig {
        RelayModuleConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p0",
                |m: &RelayModuleConfig| { &m.p0 },
                |m: &mut RelayModuleConfig| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p1",
                |m: &RelayModuleConfig| { &m.p1 },
                |m: &mut RelayModuleConfig| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p2",
                |m: &RelayModuleConfig| { &m.p2 },
                |m: &mut RelayModuleConfig| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p3",
                |m: &RelayModuleConfig| { &m.p3 },
                |m: &mut RelayModuleConfig| { &mut m.p3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p4",
                |m: &RelayModuleConfig| { &m.p4 },
                |m: &mut RelayModuleConfig| { &mut m.p4 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p5",
                |m: &RelayModuleConfig| { &m.p5 },
                |m: &mut RelayModuleConfig| { &mut m.p5 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p6",
                |m: &RelayModuleConfig| { &m.p6 },
                |m: &mut RelayModuleConfig| { &mut m.p6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p7",
                |m: &RelayModuleConfig| { &m.p7 },
                |m: &mut RelayModuleConfig| { &mut m.p7 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &RelayModuleConfig| { &m.timestamp },
                |m: &mut RelayModuleConfig| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayModuleConfig>(
                "RelayModuleConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayModuleConfig {
        static instance: ::protobuf::rt::LazyV2<RelayModuleConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayModuleConfig::new)
    }
}

impl ::protobuf::Clear for RelayModuleConfig {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.p2.clear();
        self.p3.clear();
        self.p4.clear();
        self.p5.clear();
        self.p6.clear();
        self.p7.clear();
        self.timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayModuleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayModuleConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WCModuleData {
    // message fields
    pub p0: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p1: ::protobuf::SingularPtrField<RelayOutletData>,
    pub p2: ::protobuf::SingularPtrField<RelayOutletData>,
    pub drain: ::protobuf::SingularPtrField<RelayOutletData>,
    pub pump0: ::protobuf::SingularPtrField<RelayOutletData>,
    pub pump1: ::protobuf::SingularPtrField<RelayOutletData>,
    pub pump2: ::protobuf::SingularPtrField<RelayOutletData>,
    pub pump3: ::protobuf::SingularPtrField<RelayOutletData>,
    pub timestamp: i32,
    pub actor: ::protobuf::SingularPtrField<Actor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WCModuleData {
    fn default() -> &'a WCModuleData {
        <WCModuleData as ::protobuf::Message>::default_instance()
    }
}

impl WCModuleData {
    pub fn new() -> WCModuleData {
        ::std::default::Default::default()
    }

    // .RelayOutletData p0 = 1;


    pub fn get_p0(&self) -> &RelayOutletData {
        self.p0.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: RelayOutletData) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut RelayOutletData {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> RelayOutletData {
        self.p0.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p1 = 2;


    pub fn get_p1(&self) -> &RelayOutletData {
        self.p1.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: RelayOutletData) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut RelayOutletData {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> RelayOutletData {
        self.p1.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData p2 = 3;


    pub fn get_p2(&self) -> &RelayOutletData {
        self.p2.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: RelayOutletData) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut RelayOutletData {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> RelayOutletData {
        self.p2.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData drain = 4;


    pub fn get_drain(&self) -> &RelayOutletData {
        self.drain.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_drain(&mut self) {
        self.drain.clear();
    }

    pub fn has_drain(&self) -> bool {
        self.drain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drain(&mut self, v: RelayOutletData) {
        self.drain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_drain(&mut self) -> &mut RelayOutletData {
        if self.drain.is_none() {
            self.drain.set_default();
        }
        self.drain.as_mut().unwrap()
    }

    // Take field
    pub fn take_drain(&mut self) -> RelayOutletData {
        self.drain.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData pump0 = 5;


    pub fn get_pump0(&self) -> &RelayOutletData {
        self.pump0.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump0(&mut self) {
        self.pump0.clear();
    }

    pub fn has_pump0(&self) -> bool {
        self.pump0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump0(&mut self, v: RelayOutletData) {
        self.pump0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump0(&mut self) -> &mut RelayOutletData {
        if self.pump0.is_none() {
            self.pump0.set_default();
        }
        self.pump0.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump0(&mut self) -> RelayOutletData {
        self.pump0.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData pump1 = 6;


    pub fn get_pump1(&self) -> &RelayOutletData {
        self.pump1.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump1(&mut self) {
        self.pump1.clear();
    }

    pub fn has_pump1(&self) -> bool {
        self.pump1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump1(&mut self, v: RelayOutletData) {
        self.pump1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump1(&mut self) -> &mut RelayOutletData {
        if self.pump1.is_none() {
            self.pump1.set_default();
        }
        self.pump1.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump1(&mut self) -> RelayOutletData {
        self.pump1.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData pump2 = 7;


    pub fn get_pump2(&self) -> &RelayOutletData {
        self.pump2.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump2(&mut self) {
        self.pump2.clear();
    }

    pub fn has_pump2(&self) -> bool {
        self.pump2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump2(&mut self, v: RelayOutletData) {
        self.pump2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump2(&mut self) -> &mut RelayOutletData {
        if self.pump2.is_none() {
            self.pump2.set_default();
        }
        self.pump2.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump2(&mut self) -> RelayOutletData {
        self.pump2.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // .RelayOutletData pump3 = 8;


    pub fn get_pump3(&self) -> &RelayOutletData {
        self.pump3.as_ref().unwrap_or_else(|| <RelayOutletData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump3(&mut self) {
        self.pump3.clear();
    }

    pub fn has_pump3(&self) -> bool {
        self.pump3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump3(&mut self, v: RelayOutletData) {
        self.pump3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump3(&mut self) -> &mut RelayOutletData {
        if self.pump3.is_none() {
            self.pump3.set_default();
        }
        self.pump3.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump3(&mut self) -> RelayOutletData {
        self.pump3.take().unwrap_or_else(|| RelayOutletData::new())
    }

    // int32 timestamp = 9;


    pub fn get_timestamp(&self) -> i32 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i32) {
        self.timestamp = v;
    }

    // .Actor actor = 10;


    pub fn get_actor(&self) -> &Actor {
        self.actor.as_ref().unwrap_or_else(|| <Actor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: Actor) {
        self.actor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut Actor {
        if self.actor.is_none() {
            self.actor.set_default();
        }
        self.actor.as_mut().unwrap()
    }

    // Take field
    pub fn take_actor(&mut self) -> Actor {
        self.actor.take().unwrap_or_else(|| Actor::new())
    }
}

impl ::protobuf::Message for WCModuleData {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.drain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump3 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.drain)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump0)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump1)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump2)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump3)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.drain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.actor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.drain.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump0.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump1.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump3.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timestamp != 0 {
            os.write_int32(9, self.timestamp)?;
        }
        if let Some(ref v) = self.actor.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WCModuleData {
        WCModuleData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p0",
                |m: &WCModuleData| { &m.p0 },
                |m: &mut WCModuleData| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p1",
                |m: &WCModuleData| { &m.p1 },
                |m: &mut WCModuleData| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "p2",
                |m: &WCModuleData| { &m.p2 },
                |m: &mut WCModuleData| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "drain",
                |m: &WCModuleData| { &m.drain },
                |m: &mut WCModuleData| { &mut m.drain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "pump0",
                |m: &WCModuleData| { &m.pump0 },
                |m: &mut WCModuleData| { &mut m.pump0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "pump1",
                |m: &WCModuleData| { &m.pump1 },
                |m: &mut WCModuleData| { &mut m.pump1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "pump2",
                |m: &WCModuleData| { &m.pump2 },
                |m: &mut WCModuleData| { &mut m.pump2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletData>>(
                "pump3",
                |m: &WCModuleData| { &m.pump3 },
                |m: &mut WCModuleData| { &mut m.pump3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timestamp",
                |m: &WCModuleData| { &m.timestamp },
                |m: &mut WCModuleData| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Actor>>(
                "actor",
                |m: &WCModuleData| { &m.actor },
                |m: &mut WCModuleData| { &mut m.actor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WCModuleData>(
                "WCModuleData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WCModuleData {
        static instance: ::protobuf::rt::LazyV2<WCModuleData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WCModuleData::new)
    }
}

impl ::protobuf::Clear for WCModuleData {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.p2.clear();
        self.drain.clear();
        self.pump0.clear();
        self.pump1.clear();
        self.pump2.clear();
        self.pump3.clear();
        self.timestamp = 0;
        self.actor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WCModuleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WCModuleData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WCModuleConfig {
    // message fields
    pub p0: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p1: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub p2: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub drain: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub pump0: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub pump1: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub pump2: ::protobuf::SingularPtrField<RelayOutletConfig>,
    pub pump3: ::protobuf::SingularPtrField<RelayOutletConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WCModuleConfig {
    fn default() -> &'a WCModuleConfig {
        <WCModuleConfig as ::protobuf::Message>::default_instance()
    }
}

impl WCModuleConfig {
    pub fn new() -> WCModuleConfig {
        ::std::default::Default::default()
    }

    // .RelayOutletConfig p0 = 1;


    pub fn get_p0(&self) -> &RelayOutletConfig {
        self.p0.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p0(&mut self) {
        self.p0.clear();
    }

    pub fn has_p0(&self) -> bool {
        self.p0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p0(&mut self, v: RelayOutletConfig) {
        self.p0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p0(&mut self) -> &mut RelayOutletConfig {
        if self.p0.is_none() {
            self.p0.set_default();
        }
        self.p0.as_mut().unwrap()
    }

    // Take field
    pub fn take_p0(&mut self) -> RelayOutletConfig {
        self.p0.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p1 = 2;


    pub fn get_p1(&self) -> &RelayOutletConfig {
        self.p1.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p1(&mut self) {
        self.p1.clear();
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: RelayOutletConfig) {
        self.p1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p1(&mut self) -> &mut RelayOutletConfig {
        if self.p1.is_none() {
            self.p1.set_default();
        }
        self.p1.as_mut().unwrap()
    }

    // Take field
    pub fn take_p1(&mut self) -> RelayOutletConfig {
        self.p1.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig p2 = 3;


    pub fn get_p2(&self) -> &RelayOutletConfig {
        self.p2.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_p2(&mut self) {
        self.p2.clear();
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: RelayOutletConfig) {
        self.p2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2(&mut self) -> &mut RelayOutletConfig {
        if self.p2.is_none() {
            self.p2.set_default();
        }
        self.p2.as_mut().unwrap()
    }

    // Take field
    pub fn take_p2(&mut self) -> RelayOutletConfig {
        self.p2.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig drain = 4;


    pub fn get_drain(&self) -> &RelayOutletConfig {
        self.drain.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_drain(&mut self) {
        self.drain.clear();
    }

    pub fn has_drain(&self) -> bool {
        self.drain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drain(&mut self, v: RelayOutletConfig) {
        self.drain = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_drain(&mut self) -> &mut RelayOutletConfig {
        if self.drain.is_none() {
            self.drain.set_default();
        }
        self.drain.as_mut().unwrap()
    }

    // Take field
    pub fn take_drain(&mut self) -> RelayOutletConfig {
        self.drain.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig pump0 = 5;


    pub fn get_pump0(&self) -> &RelayOutletConfig {
        self.pump0.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump0(&mut self) {
        self.pump0.clear();
    }

    pub fn has_pump0(&self) -> bool {
        self.pump0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump0(&mut self, v: RelayOutletConfig) {
        self.pump0 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump0(&mut self) -> &mut RelayOutletConfig {
        if self.pump0.is_none() {
            self.pump0.set_default();
        }
        self.pump0.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump0(&mut self) -> RelayOutletConfig {
        self.pump0.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig pump1 = 6;


    pub fn get_pump1(&self) -> &RelayOutletConfig {
        self.pump1.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump1(&mut self) {
        self.pump1.clear();
    }

    pub fn has_pump1(&self) -> bool {
        self.pump1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump1(&mut self, v: RelayOutletConfig) {
        self.pump1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump1(&mut self) -> &mut RelayOutletConfig {
        if self.pump1.is_none() {
            self.pump1.set_default();
        }
        self.pump1.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump1(&mut self) -> RelayOutletConfig {
        self.pump1.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig pump2 = 7;


    pub fn get_pump2(&self) -> &RelayOutletConfig {
        self.pump2.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump2(&mut self) {
        self.pump2.clear();
    }

    pub fn has_pump2(&self) -> bool {
        self.pump2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump2(&mut self, v: RelayOutletConfig) {
        self.pump2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump2(&mut self) -> &mut RelayOutletConfig {
        if self.pump2.is_none() {
            self.pump2.set_default();
        }
        self.pump2.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump2(&mut self) -> RelayOutletConfig {
        self.pump2.take().unwrap_or_else(|| RelayOutletConfig::new())
    }

    // .RelayOutletConfig pump3 = 8;


    pub fn get_pump3(&self) -> &RelayOutletConfig {
        self.pump3.as_ref().unwrap_or_else(|| <RelayOutletConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pump3(&mut self) {
        self.pump3.clear();
    }

    pub fn has_pump3(&self) -> bool {
        self.pump3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pump3(&mut self, v: RelayOutletConfig) {
        self.pump3 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pump3(&mut self) -> &mut RelayOutletConfig {
        if self.pump3.is_none() {
            self.pump3.set_default();
        }
        self.pump3.as_mut().unwrap()
    }

    // Take field
    pub fn take_pump3(&mut self) -> RelayOutletConfig {
        self.pump3.take().unwrap_or_else(|| RelayOutletConfig::new())
    }
}

impl ::protobuf::Message for WCModuleConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.p0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.p2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.drain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump0 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pump3 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p0)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p1)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.p2)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.drain)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump0)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump1)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump2)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pump3)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.p2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.drain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pump3.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.p0.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p1.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.p2.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.drain.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump0.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump1.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump2.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pump3.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WCModuleConfig {
        WCModuleConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p0",
                |m: &WCModuleConfig| { &m.p0 },
                |m: &mut WCModuleConfig| { &mut m.p0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p1",
                |m: &WCModuleConfig| { &m.p1 },
                |m: &mut WCModuleConfig| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "p2",
                |m: &WCModuleConfig| { &m.p2 },
                |m: &mut WCModuleConfig| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "drain",
                |m: &WCModuleConfig| { &m.drain },
                |m: &mut WCModuleConfig| { &mut m.drain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "pump0",
                |m: &WCModuleConfig| { &m.pump0 },
                |m: &mut WCModuleConfig| { &mut m.pump0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "pump1",
                |m: &WCModuleConfig| { &m.pump1 },
                |m: &mut WCModuleConfig| { &mut m.pump1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "pump2",
                |m: &WCModuleConfig| { &m.pump2 },
                |m: &mut WCModuleConfig| { &mut m.pump2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelayOutletConfig>>(
                "pump3",
                |m: &WCModuleConfig| { &m.pump3 },
                |m: &mut WCModuleConfig| { &mut m.pump3 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WCModuleConfig>(
                "WCModuleConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WCModuleConfig {
        static instance: ::protobuf::rt::LazyV2<WCModuleConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WCModuleConfig::new)
    }
}

impl ::protobuf::Clear for WCModuleConfig {
    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.p2.clear();
        self.drain.clear();
        self.pump0.clear();
        self.pump1.clear();
        self.pump2.clear();
        self.pump3.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WCModuleConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WCModuleConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhonePositionData {
    // message fields
    pub lat: f32,
    pub log: f32,
    pub accuracy: f32,
    pub altitude: f64,
    pub bearing: f32,
    pub speed: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhonePositionData {
    fn default() -> &'a PhonePositionData {
        <PhonePositionData as ::protobuf::Message>::default_instance()
    }
}

impl PhonePositionData {
    pub fn new() -> PhonePositionData {
        ::std::default::Default::default()
    }

    // float lat = 1;


    pub fn get_lat(&self) -> f32 {
        self.lat
    }
    pub fn clear_lat(&mut self) {
        self.lat = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f32) {
        self.lat = v;
    }

    // float log = 2;


    pub fn get_log(&self) -> f32 {
        self.log
    }
    pub fn clear_log(&mut self) {
        self.log = 0.;
    }

    // Param is passed by value, moved
    pub fn set_log(&mut self, v: f32) {
        self.log = v;
    }

    // float accuracy = 3;


    pub fn get_accuracy(&self) -> f32 {
        self.accuracy
    }
    pub fn clear_accuracy(&mut self) {
        self.accuracy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_accuracy(&mut self, v: f32) {
        self.accuracy = v;
    }

    // double altitude = 4;


    pub fn get_altitude(&self) -> f64 {
        self.altitude
    }
    pub fn clear_altitude(&mut self) {
        self.altitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_altitude(&mut self, v: f64) {
        self.altitude = v;
    }

    // float bearing = 5;


    pub fn get_bearing(&self) -> f32 {
        self.bearing
    }
    pub fn clear_bearing(&mut self) {
        self.bearing = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bearing(&mut self, v: f32) {
        self.bearing = v;
    }

    // float speed = 7;


    pub fn get_speed(&self) -> f32 {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = 0.;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = v;
    }
}

impl ::protobuf::Message for PhonePositionData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.lat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.log = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.accuracy = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.altitude = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bearing = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.speed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lat != 0. {
            my_size += 5;
        }
        if self.log != 0. {
            my_size += 5;
        }
        if self.accuracy != 0. {
            my_size += 5;
        }
        if self.altitude != 0. {
            my_size += 9;
        }
        if self.bearing != 0. {
            my_size += 5;
        }
        if self.speed != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.lat != 0. {
            os.write_float(1, self.lat)?;
        }
        if self.log != 0. {
            os.write_float(2, self.log)?;
        }
        if self.accuracy != 0. {
            os.write_float(3, self.accuracy)?;
        }
        if self.altitude != 0. {
            os.write_double(4, self.altitude)?;
        }
        if self.bearing != 0. {
            os.write_float(5, self.bearing)?;
        }
        if self.speed != 0. {
            os.write_float(7, self.speed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhonePositionData {
        PhonePositionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "lat",
                |m: &PhonePositionData| { &m.lat },
                |m: &mut PhonePositionData| { &mut m.lat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "log",
                |m: &PhonePositionData| { &m.log },
                |m: &mut PhonePositionData| { &mut m.log },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "accuracy",
                |m: &PhonePositionData| { &m.accuracy },
                |m: &mut PhonePositionData| { &mut m.accuracy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "altitude",
                |m: &PhonePositionData| { &m.altitude },
                |m: &mut PhonePositionData| { &mut m.altitude },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bearing",
                |m: &PhonePositionData| { &m.bearing },
                |m: &mut PhonePositionData| { &mut m.bearing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "speed",
                |m: &PhonePositionData| { &m.speed },
                |m: &mut PhonePositionData| { &mut m.speed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhonePositionData>(
                "PhonePositionData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhonePositionData {
        static instance: ::protobuf::rt::LazyV2<PhonePositionData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhonePositionData::new)
    }
}

impl ::protobuf::Clear for PhonePositionData {
    fn clear(&mut self) {
        self.lat = 0.;
        self.log = 0.;
        self.accuracy = 0.;
        self.altitude = 0.;
        self.bearing = 0.;
        self.speed = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhonePositionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhonePositionData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhonePositionConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhonePositionConfig {
    fn default() -> &'a PhonePositionConfig {
        <PhonePositionConfig as ::protobuf::Message>::default_instance()
    }
}

impl PhonePositionConfig {
    pub fn new() -> PhonePositionConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PhonePositionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhonePositionConfig {
        PhonePositionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhonePositionConfig>(
                "PhonePositionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhonePositionConfig {
        static instance: ::protobuf::rt::LazyV2<PhonePositionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhonePositionConfig::new)
    }
}

impl ::protobuf::Clear for PhonePositionConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhonePositionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhonePositionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneAccelerationData {
    // message fields
    pub gx: f32,
    pub gy: f32,
    pub gz: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneAccelerationData {
    fn default() -> &'a PhoneAccelerationData {
        <PhoneAccelerationData as ::protobuf::Message>::default_instance()
    }
}

impl PhoneAccelerationData {
    pub fn new() -> PhoneAccelerationData {
        ::std::default::Default::default()
    }

    // float gx = 1;


    pub fn get_gx(&self) -> f32 {
        self.gx
    }
    pub fn clear_gx(&mut self) {
        self.gx = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gx(&mut self, v: f32) {
        self.gx = v;
    }

    // float gy = 2;


    pub fn get_gy(&self) -> f32 {
        self.gy
    }
    pub fn clear_gy(&mut self) {
        self.gy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gy(&mut self, v: f32) {
        self.gy = v;
    }

    // float gz = 3;


    pub fn get_gz(&self) -> f32 {
        self.gz
    }
    pub fn clear_gz(&mut self) {
        self.gz = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gz(&mut self, v: f32) {
        self.gz = v;
    }
}

impl ::protobuf::Message for PhoneAccelerationData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gx = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gy = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gz = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gx != 0. {
            my_size += 5;
        }
        if self.gy != 0. {
            my_size += 5;
        }
        if self.gz != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.gx != 0. {
            os.write_float(1, self.gx)?;
        }
        if self.gy != 0. {
            os.write_float(2, self.gy)?;
        }
        if self.gz != 0. {
            os.write_float(3, self.gz)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneAccelerationData {
        PhoneAccelerationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "gx",
                |m: &PhoneAccelerationData| { &m.gx },
                |m: &mut PhoneAccelerationData| { &mut m.gx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "gy",
                |m: &PhoneAccelerationData| { &m.gy },
                |m: &mut PhoneAccelerationData| { &mut m.gy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "gz",
                |m: &PhoneAccelerationData| { &m.gz },
                |m: &mut PhoneAccelerationData| { &mut m.gz },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneAccelerationData>(
                "PhoneAccelerationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneAccelerationData {
        static instance: ::protobuf::rt::LazyV2<PhoneAccelerationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneAccelerationData::new)
    }
}

impl ::protobuf::Clear for PhoneAccelerationData {
    fn clear(&mut self) {
        self.gx = 0.;
        self.gy = 0.;
        self.gz = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneAccelerationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneAccelerationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneAccelerationConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneAccelerationConfig {
    fn default() -> &'a PhoneAccelerationConfig {
        <PhoneAccelerationConfig as ::protobuf::Message>::default_instance()
    }
}

impl PhoneAccelerationConfig {
    pub fn new() -> PhoneAccelerationConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PhoneAccelerationConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneAccelerationConfig {
        PhoneAccelerationConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneAccelerationConfig>(
                "PhoneAccelerationConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneAccelerationConfig {
        static instance: ::protobuf::rt::LazyV2<PhoneAccelerationConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneAccelerationConfig::new)
    }
}

impl ::protobuf::Clear for PhoneAccelerationConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneAccelerationConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneAccelerationConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneAmbientLightData {
    // message fields
    pub si_lux: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneAmbientLightData {
    fn default() -> &'a PhoneAmbientLightData {
        <PhoneAmbientLightData as ::protobuf::Message>::default_instance()
    }
}

impl PhoneAmbientLightData {
    pub fn new() -> PhoneAmbientLightData {
        ::std::default::Default::default()
    }

    // float si_lux = 1;


    pub fn get_si_lux(&self) -> f32 {
        self.si_lux
    }
    pub fn clear_si_lux(&mut self) {
        self.si_lux = 0.;
    }

    // Param is passed by value, moved
    pub fn set_si_lux(&mut self, v: f32) {
        self.si_lux = v;
    }
}

impl ::protobuf::Message for PhoneAmbientLightData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.si_lux = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.si_lux != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.si_lux != 0. {
            os.write_float(1, self.si_lux)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneAmbientLightData {
        PhoneAmbientLightData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "si_lux",
                |m: &PhoneAmbientLightData| { &m.si_lux },
                |m: &mut PhoneAmbientLightData| { &mut m.si_lux },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneAmbientLightData>(
                "PhoneAmbientLightData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneAmbientLightData {
        static instance: ::protobuf::rt::LazyV2<PhoneAmbientLightData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneAmbientLightData::new)
    }
}

impl ::protobuf::Clear for PhoneAmbientLightData {
    fn clear(&mut self) {
        self.si_lux = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneAmbientLightData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneAmbientLightData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneAmbientLightConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneAmbientLightConfig {
    fn default() -> &'a PhoneAmbientLightConfig {
        <PhoneAmbientLightConfig as ::protobuf::Message>::default_instance()
    }
}

impl PhoneAmbientLightConfig {
    pub fn new() -> PhoneAmbientLightConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PhoneAmbientLightConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneAmbientLightConfig {
        PhoneAmbientLightConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneAmbientLightConfig>(
                "PhoneAmbientLightConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneAmbientLightConfig {
        static instance: ::protobuf::rt::LazyV2<PhoneAmbientLightConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneAmbientLightConfig::new)
    }
}

impl ::protobuf::Clear for PhoneAmbientLightConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneAmbientLightConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneAmbientLightConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhonePressureData {
    // message fields
    pub hpa: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhonePressureData {
    fn default() -> &'a PhonePressureData {
        <PhonePressureData as ::protobuf::Message>::default_instance()
    }
}

impl PhonePressureData {
    pub fn new() -> PhonePressureData {
        ::std::default::Default::default()
    }

    // float hpa = 1;


    pub fn get_hpa(&self) -> f32 {
        self.hpa
    }
    pub fn clear_hpa(&mut self) {
        self.hpa = 0.;
    }

    // Param is passed by value, moved
    pub fn set_hpa(&mut self, v: f32) {
        self.hpa = v;
    }
}

impl ::protobuf::Message for PhonePressureData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.hpa = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hpa != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.hpa != 0. {
            os.write_float(1, self.hpa)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhonePressureData {
        PhonePressureData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "hpa",
                |m: &PhonePressureData| { &m.hpa },
                |m: &mut PhonePressureData| { &mut m.hpa },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhonePressureData>(
                "PhonePressureData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhonePressureData {
        static instance: ::protobuf::rt::LazyV2<PhonePressureData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhonePressureData::new)
    }
}

impl ::protobuf::Clear for PhonePressureData {
    fn clear(&mut self) {
        self.hpa = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhonePressureData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhonePressureData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhonePressureConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhonePressureConfig {
    fn default() -> &'a PhonePressureConfig {
        <PhonePressureConfig as ::protobuf::Message>::default_instance()
    }
}

impl PhonePressureConfig {
    pub fn new() -> PhonePressureConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PhonePressureConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhonePressureConfig {
        PhonePressureConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhonePressureConfig>(
                "PhonePressureConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhonePressureConfig {
        static instance: ::protobuf::rt::LazyV2<PhonePressureConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhonePressureConfig::new)
    }
}

impl ::protobuf::Clear for PhonePressureConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhonePressureConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhonePressureConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Point {
    // message fields
    pub x: i32,
    pub y: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // int32 x = 1;


    pub fn get_x(&self) -> i32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: i32) {
        self.x = v;
    }

    // int32 y = 2;


    pub fn get_y(&self) -> i32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: i32) {
        self.y = v;
    }
}

impl ::protobuf::Message for Point {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.x = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.y = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::value_size(1, self.x, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::value_size(2, self.y, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Point {
        Point::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "x",
                |m: &Point| { &m.x },
                |m: &mut Point| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "y",
                |m: &Point| { &m.y },
                |m: &mut Point| { &mut m.y },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Point>(
                "Point",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Point {
        static instance: ::protobuf::rt::LazyV2<Point> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Point::new)
    }
}

impl ::protobuf::Clear for Point {
    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rect {
    // message fields
    pub top: i32,
    pub right: i32,
    pub bottom: i32,
    pub left: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rect {
    fn default() -> &'a Rect {
        <Rect as ::protobuf::Message>::default_instance()
    }
}

impl Rect {
    pub fn new() -> Rect {
        ::std::default::Default::default()
    }

    // int32 top = 1;


    pub fn get_top(&self) -> i32 {
        self.top
    }
    pub fn clear_top(&mut self) {
        self.top = 0;
    }

    // Param is passed by value, moved
    pub fn set_top(&mut self, v: i32) {
        self.top = v;
    }

    // int32 right = 2;


    pub fn get_right(&self) -> i32 {
        self.right
    }
    pub fn clear_right(&mut self) {
        self.right = 0;
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: i32) {
        self.right = v;
    }

    // int32 bottom = 3;


    pub fn get_bottom(&self) -> i32 {
        self.bottom
    }
    pub fn clear_bottom(&mut self) {
        self.bottom = 0;
    }

    // Param is passed by value, moved
    pub fn set_bottom(&mut self, v: i32) {
        self.bottom = v;
    }

    // int32 left = 4;


    pub fn get_left(&self) -> i32 {
        self.left
    }
    pub fn clear_left(&mut self) {
        self.left = 0;
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: i32) {
        self.left = v;
    }
}

impl ::protobuf::Message for Rect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.top = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bottom = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.top != 0 {
            my_size += ::protobuf::rt::value_size(1, self.top, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right != 0 {
            my_size += ::protobuf::rt::value_size(2, self.right, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bottom != 0 {
            my_size += ::protobuf::rt::value_size(3, self.bottom, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.left != 0 {
            my_size += ::protobuf::rt::value_size(4, self.left, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.top != 0 {
            os.write_int32(1, self.top)?;
        }
        if self.right != 0 {
            os.write_int32(2, self.right)?;
        }
        if self.bottom != 0 {
            os.write_int32(3, self.bottom)?;
        }
        if self.left != 0 {
            os.write_int32(4, self.left)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rect {
        Rect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "top",
                |m: &Rect| { &m.top },
                |m: &mut Rect| { &mut m.top },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "right",
                |m: &Rect| { &m.right },
                |m: &mut Rect| { &mut m.right },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bottom",
                |m: &Rect| { &m.bottom },
                |m: &mut Rect| { &mut m.bottom },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "left",
                |m: &Rect| { &m.left },
                |m: &mut Rect| { &mut m.left },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rect>(
                "Rect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rect {
        static instance: ::protobuf::rt::LazyV2<Rect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rect::new)
    }
}

impl ::protobuf::Clear for Rect {
    fn clear(&mut self) {
        self.top = 0;
        self.right = 0;
        self.bottom = 0;
        self.left = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraFace {
    // message fields
    pub id: i32,
    pub score: i32,
    pub rect: ::protobuf::SingularPtrField<Rect>,
    pub mouth: ::protobuf::SingularPtrField<Point>,
    pub leftEye: ::protobuf::SingularPtrField<Point>,
    pub rightEye: ::protobuf::SingularPtrField<Point>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraFace {
    fn default() -> &'a CameraFace {
        <CameraFace as ::protobuf::Message>::default_instance()
    }
}

impl CameraFace {
    pub fn new() -> CameraFace {
        ::std::default::Default::default()
    }

    // int32 id = 1;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // int32 score = 2;


    pub fn get_score(&self) -> i32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = v;
    }

    // .Rect rect = 3;


    pub fn get_rect(&self) -> &Rect {
        self.rect.as_ref().unwrap_or_else(|| <Rect as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rect(&mut self) {
        self.rect.clear();
    }

    pub fn has_rect(&self) -> bool {
        self.rect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rect(&mut self, v: Rect) {
        self.rect = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rect(&mut self) -> &mut Rect {
        if self.rect.is_none() {
            self.rect.set_default();
        }
        self.rect.as_mut().unwrap()
    }

    // Take field
    pub fn take_rect(&mut self) -> Rect {
        self.rect.take().unwrap_or_else(|| Rect::new())
    }

    // .Point mouth = 4;


    pub fn get_mouth(&self) -> &Point {
        self.mouth.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mouth(&mut self) {
        self.mouth.clear();
    }

    pub fn has_mouth(&self) -> bool {
        self.mouth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mouth(&mut self, v: Point) {
        self.mouth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mouth(&mut self) -> &mut Point {
        if self.mouth.is_none() {
            self.mouth.set_default();
        }
        self.mouth.as_mut().unwrap()
    }

    // Take field
    pub fn take_mouth(&mut self) -> Point {
        self.mouth.take().unwrap_or_else(|| Point::new())
    }

    // .Point leftEye = 5;


    pub fn get_leftEye(&self) -> &Point {
        self.leftEye.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leftEye(&mut self) {
        self.leftEye.clear();
    }

    pub fn has_leftEye(&self) -> bool {
        self.leftEye.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leftEye(&mut self, v: Point) {
        self.leftEye = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leftEye(&mut self) -> &mut Point {
        if self.leftEye.is_none() {
            self.leftEye.set_default();
        }
        self.leftEye.as_mut().unwrap()
    }

    // Take field
    pub fn take_leftEye(&mut self) -> Point {
        self.leftEye.take().unwrap_or_else(|| Point::new())
    }

    // .Point rightEye = 6;


    pub fn get_rightEye(&self) -> &Point {
        self.rightEye.as_ref().unwrap_or_else(|| <Point as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rightEye(&mut self) {
        self.rightEye.clear();
    }

    pub fn has_rightEye(&self) -> bool {
        self.rightEye.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rightEye(&mut self, v: Point) {
        self.rightEye = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rightEye(&mut self) -> &mut Point {
        if self.rightEye.is_none() {
            self.rightEye.set_default();
        }
        self.rightEye.as_mut().unwrap()
    }

    // Take field
    pub fn take_rightEye(&mut self) -> Point {
        self.rightEye.take().unwrap_or_else(|| Point::new())
    }
}

impl ::protobuf::Message for CameraFace {
    fn is_initialized(&self) -> bool {
        for v in &self.rect {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mouth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leftEye {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rightEye {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rect)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mouth)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leftEye)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rightEye)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(2, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.rect.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mouth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.leftEye.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rightEye.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.score != 0 {
            os.write_int32(2, self.score)?;
        }
        if let Some(ref v) = self.rect.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mouth.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.leftEye.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rightEye.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraFace {
        CameraFace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &CameraFace| { &m.id },
                |m: &mut CameraFace| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &CameraFace| { &m.score },
                |m: &mut CameraFace| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Rect>>(
                "rect",
                |m: &CameraFace| { &m.rect },
                |m: &mut CameraFace| { &mut m.rect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "mouth",
                |m: &CameraFace| { &m.mouth },
                |m: &mut CameraFace| { &mut m.mouth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "leftEye",
                |m: &CameraFace| { &m.leftEye },
                |m: &mut CameraFace| { &mut m.leftEye },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Point>>(
                "rightEye",
                |m: &CameraFace| { &m.rightEye },
                |m: &mut CameraFace| { &mut m.rightEye },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CameraFace>(
                "CameraFace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CameraFace {
        static instance: ::protobuf::rt::LazyV2<CameraFace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CameraFace::new)
    }
}

impl ::protobuf::Clear for CameraFace {
    fn clear(&mut self) {
        self.id = 0;
        self.score = 0;
        self.rect.clear();
        self.mouth.clear();
        self.leftEye.clear();
        self.rightEye.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraFace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraFace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneStreamingData {
    // message fields
    pub status: PhoneStreamingStatus,
    pub fps: f32,
    pub bitrate: f32,
    pub faces: ::protobuf::RepeatedField<CameraFace>,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneStreamingData {
    fn default() -> &'a PhoneStreamingData {
        <PhoneStreamingData as ::protobuf::Message>::default_instance()
    }
}

impl PhoneStreamingData {
    pub fn new() -> PhoneStreamingData {
        ::std::default::Default::default()
    }

    // .PhoneStreamingStatus status = 1;


    pub fn get_status(&self) -> PhoneStreamingStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = PhoneStreamingStatus::STOPPED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PhoneStreamingStatus) {
        self.status = v;
    }

    // float fps = 2;


    pub fn get_fps(&self) -> f32 {
        self.fps
    }
    pub fn clear_fps(&mut self) {
        self.fps = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = v;
    }

    // float bitrate = 3;


    pub fn get_bitrate(&self) -> f32 {
        self.bitrate
    }
    pub fn clear_bitrate(&mut self) {
        self.bitrate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: f32) {
        self.bitrate = v;
    }

    // repeated .CameraFace faces = 4;


    pub fn get_faces(&self) -> &[CameraFace] {
        &self.faces
    }
    pub fn clear_faces(&mut self) {
        self.faces.clear();
    }

    // Param is passed by value, moved
    pub fn set_faces(&mut self, v: ::protobuf::RepeatedField<CameraFace>) {
        self.faces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_faces(&mut self) -> &mut ::protobuf::RepeatedField<CameraFace> {
        &mut self.faces
    }

    // Take field
    pub fn take_faces(&mut self) -> ::protobuf::RepeatedField<CameraFace> {
        ::std::mem::replace(&mut self.faces, ::protobuf::RepeatedField::new())
    }

    // string error = 5;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PhoneStreamingData {
    fn is_initialized(&self) -> bool {
        for v in &self.faces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fps = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bitrate = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.faces)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != PhoneStreamingStatus::STOPPED {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if self.fps != 0. {
            my_size += 5;
        }
        if self.bitrate != 0. {
            my_size += 5;
        }
        for value in &self.faces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != PhoneStreamingStatus::STOPPED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.fps != 0. {
            os.write_float(2, self.fps)?;
        }
        if self.bitrate != 0. {
            os.write_float(3, self.bitrate)?;
        }
        for v in &self.faces {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.error.is_empty() {
            os.write_string(5, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneStreamingData {
        PhoneStreamingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhoneStreamingStatus>>(
                "status",
                |m: &PhoneStreamingData| { &m.status },
                |m: &mut PhoneStreamingData| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fps",
                |m: &PhoneStreamingData| { &m.fps },
                |m: &mut PhoneStreamingData| { &mut m.fps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bitrate",
                |m: &PhoneStreamingData| { &m.bitrate },
                |m: &mut PhoneStreamingData| { &mut m.bitrate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraFace>>(
                "faces",
                |m: &PhoneStreamingData| { &m.faces },
                |m: &mut PhoneStreamingData| { &mut m.faces },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &PhoneStreamingData| { &m.error },
                |m: &mut PhoneStreamingData| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneStreamingData>(
                "PhoneStreamingData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneStreamingData {
        static instance: ::protobuf::rt::LazyV2<PhoneStreamingData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneStreamingData::new)
    }
}

impl ::protobuf::Clear for PhoneStreamingData {
    fn clear(&mut self) {
        self.status = PhoneStreamingStatus::STOPPED;
        self.fps = 0.;
        self.bitrate = 0.;
        self.faces.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneStreamingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStreamingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhoneStreamingConfig {
    // message fields
    pub activated: bool,
    pub output: PhoneStreamingOutput,
    pub url: ::std::string::String,
    pub camera: PhoneStreamingCamera,
    pub light: bool,
    pub audio: bool,
    pub autoFocus: bool,
    pub stabilization: bool,
    pub faceDetection: bool,
    pub zoom: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhoneStreamingConfig {
    fn default() -> &'a PhoneStreamingConfig {
        <PhoneStreamingConfig as ::protobuf::Message>::default_instance()
    }
}

impl PhoneStreamingConfig {
    pub fn new() -> PhoneStreamingConfig {
        ::std::default::Default::default()
    }

    // bool activated = 1;


    pub fn get_activated(&self) -> bool {
        self.activated
    }
    pub fn clear_activated(&mut self) {
        self.activated = false;
    }

    // Param is passed by value, moved
    pub fn set_activated(&mut self, v: bool) {
        self.activated = v;
    }

    // .PhoneStreamingOutput output = 2;


    pub fn get_output(&self) -> PhoneStreamingOutput {
        self.output
    }
    pub fn clear_output(&mut self) {
        self.output = PhoneStreamingOutput::STREAM;
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: PhoneStreamingOutput) {
        self.output = v;
    }

    // string url = 3;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // .PhoneStreamingCamera camera = 4;


    pub fn get_camera(&self) -> PhoneStreamingCamera {
        self.camera
    }
    pub fn clear_camera(&mut self) {
        self.camera = PhoneStreamingCamera::BACK;
    }

    // Param is passed by value, moved
    pub fn set_camera(&mut self, v: PhoneStreamingCamera) {
        self.camera = v;
    }

    // bool light = 5;


    pub fn get_light(&self) -> bool {
        self.light
    }
    pub fn clear_light(&mut self) {
        self.light = false;
    }

    // Param is passed by value, moved
    pub fn set_light(&mut self, v: bool) {
        self.light = v;
    }

    // bool audio = 6;


    pub fn get_audio(&self) -> bool {
        self.audio
    }
    pub fn clear_audio(&mut self) {
        self.audio = false;
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: bool) {
        self.audio = v;
    }

    // bool autoFocus = 7;


    pub fn get_autoFocus(&self) -> bool {
        self.autoFocus
    }
    pub fn clear_autoFocus(&mut self) {
        self.autoFocus = false;
    }

    // Param is passed by value, moved
    pub fn set_autoFocus(&mut self, v: bool) {
        self.autoFocus = v;
    }

    // bool stabilization = 8;


    pub fn get_stabilization(&self) -> bool {
        self.stabilization
    }
    pub fn clear_stabilization(&mut self) {
        self.stabilization = false;
    }

    // Param is passed by value, moved
    pub fn set_stabilization(&mut self, v: bool) {
        self.stabilization = v;
    }

    // bool faceDetection = 9;


    pub fn get_faceDetection(&self) -> bool {
        self.faceDetection
    }
    pub fn clear_faceDetection(&mut self) {
        self.faceDetection = false;
    }

    // Param is passed by value, moved
    pub fn set_faceDetection(&mut self, v: bool) {
        self.faceDetection = v;
    }

    // int32 zoom = 10;


    pub fn get_zoom(&self) -> i32 {
        self.zoom
    }
    pub fn clear_zoom(&mut self) {
        self.zoom = 0;
    }

    // Param is passed by value, moved
    pub fn set_zoom(&mut self, v: i32) {
        self.zoom = v;
    }
}

impl ::protobuf::Message for PhoneStreamingConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.activated = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.camera, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.light = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.audio = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoFocus = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stabilization = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.faceDetection = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.zoom = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.activated != false {
            my_size += 2;
        }
        if self.output != PhoneStreamingOutput::STREAM {
            my_size += ::protobuf::rt::enum_size(2, self.output);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if self.camera != PhoneStreamingCamera::BACK {
            my_size += ::protobuf::rt::enum_size(4, self.camera);
        }
        if self.light != false {
            my_size += 2;
        }
        if self.audio != false {
            my_size += 2;
        }
        if self.autoFocus != false {
            my_size += 2;
        }
        if self.stabilization != false {
            my_size += 2;
        }
        if self.faceDetection != false {
            my_size += 2;
        }
        if self.zoom != 0 {
            my_size += ::protobuf::rt::value_size(10, self.zoom, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.activated != false {
            os.write_bool(1, self.activated)?;
        }
        if self.output != PhoneStreamingOutput::STREAM {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.output))?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if self.camera != PhoneStreamingCamera::BACK {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.camera))?;
        }
        if self.light != false {
            os.write_bool(5, self.light)?;
        }
        if self.audio != false {
            os.write_bool(6, self.audio)?;
        }
        if self.autoFocus != false {
            os.write_bool(7, self.autoFocus)?;
        }
        if self.stabilization != false {
            os.write_bool(8, self.stabilization)?;
        }
        if self.faceDetection != false {
            os.write_bool(9, self.faceDetection)?;
        }
        if self.zoom != 0 {
            os.write_int32(10, self.zoom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhoneStreamingConfig {
        PhoneStreamingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "activated",
                |m: &PhoneStreamingConfig| { &m.activated },
                |m: &mut PhoneStreamingConfig| { &mut m.activated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhoneStreamingOutput>>(
                "output",
                |m: &PhoneStreamingConfig| { &m.output },
                |m: &mut PhoneStreamingConfig| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &PhoneStreamingConfig| { &m.url },
                |m: &mut PhoneStreamingConfig| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhoneStreamingCamera>>(
                "camera",
                |m: &PhoneStreamingConfig| { &m.camera },
                |m: &mut PhoneStreamingConfig| { &mut m.camera },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "light",
                |m: &PhoneStreamingConfig| { &m.light },
                |m: &mut PhoneStreamingConfig| { &mut m.light },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "audio",
                |m: &PhoneStreamingConfig| { &m.audio },
                |m: &mut PhoneStreamingConfig| { &mut m.audio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoFocus",
                |m: &PhoneStreamingConfig| { &m.autoFocus },
                |m: &mut PhoneStreamingConfig| { &mut m.autoFocus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stabilization",
                |m: &PhoneStreamingConfig| { &m.stabilization },
                |m: &mut PhoneStreamingConfig| { &mut m.stabilization },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "faceDetection",
                |m: &PhoneStreamingConfig| { &m.faceDetection },
                |m: &mut PhoneStreamingConfig| { &mut m.faceDetection },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "zoom",
                |m: &PhoneStreamingConfig| { &m.zoom },
                |m: &mut PhoneStreamingConfig| { &mut m.zoom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhoneStreamingConfig>(
                "PhoneStreamingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhoneStreamingConfig {
        static instance: ::protobuf::rt::LazyV2<PhoneStreamingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhoneStreamingConfig::new)
    }
}

impl ::protobuf::Clear for PhoneStreamingConfig {
    fn clear(&mut self) {
        self.activated = false;
        self.output = PhoneStreamingOutput::STREAM;
        self.url.clear();
        self.camera = PhoneStreamingCamera::BACK;
        self.light = false;
        self.audio = false;
        self.autoFocus = false;
        self.stabilization = false;
        self.faceDetection = false;
        self.zoom = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhoneStreamingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStreamingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputerStreamingData {
    // message fields
    pub status: PhoneStreamingStatus,
    pub fps: f32,
    pub bitrate: f32,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputerStreamingData {
    fn default() -> &'a ComputerStreamingData {
        <ComputerStreamingData as ::protobuf::Message>::default_instance()
    }
}

impl ComputerStreamingData {
    pub fn new() -> ComputerStreamingData {
        ::std::default::Default::default()
    }

    // .PhoneStreamingStatus status = 1;


    pub fn get_status(&self) -> PhoneStreamingStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = PhoneStreamingStatus::STOPPED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PhoneStreamingStatus) {
        self.status = v;
    }

    // float fps = 2;


    pub fn get_fps(&self) -> f32 {
        self.fps
    }
    pub fn clear_fps(&mut self) {
        self.fps = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = v;
    }

    // float bitrate = 3;


    pub fn get_bitrate(&self) -> f32 {
        self.bitrate
    }
    pub fn clear_bitrate(&mut self) {
        self.bitrate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: f32) {
        self.bitrate = v;
    }

    // string error = 4;


    pub fn get_error(&self) -> &str {
        &self.error
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ComputerStreamingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.fps = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bitrate = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != PhoneStreamingStatus::STOPPED {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if self.fps != 0. {
            my_size += 5;
        }
        if self.bitrate != 0. {
            my_size += 5;
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != PhoneStreamingStatus::STOPPED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.fps != 0. {
            os.write_float(2, self.fps)?;
        }
        if self.bitrate != 0. {
            os.write_float(3, self.bitrate)?;
        }
        if !self.error.is_empty() {
            os.write_string(4, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputerStreamingData {
        ComputerStreamingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhoneStreamingStatus>>(
                "status",
                |m: &ComputerStreamingData| { &m.status },
                |m: &mut ComputerStreamingData| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "fps",
                |m: &ComputerStreamingData| { &m.fps },
                |m: &mut ComputerStreamingData| { &mut m.fps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "bitrate",
                |m: &ComputerStreamingData| { &m.bitrate },
                |m: &mut ComputerStreamingData| { &mut m.bitrate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &ComputerStreamingData| { &m.error },
                |m: &mut ComputerStreamingData| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputerStreamingData>(
                "ComputerStreamingData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputerStreamingData {
        static instance: ::protobuf::rt::LazyV2<ComputerStreamingData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputerStreamingData::new)
    }
}

impl ::protobuf::Clear for ComputerStreamingData {
    fn clear(&mut self) {
        self.status = PhoneStreamingStatus::STOPPED;
        self.fps = 0.;
        self.bitrate = 0.;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputerStreamingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputerStreamingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputerStreamingConfig {
    // message fields
    pub activated: bool,
    pub camera: ::std::string::String,
    pub output: PhoneStreamingOutput,
    pub url: ::std::string::String,
    pub arguments: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputerStreamingConfig {
    fn default() -> &'a ComputerStreamingConfig {
        <ComputerStreamingConfig as ::protobuf::Message>::default_instance()
    }
}

impl ComputerStreamingConfig {
    pub fn new() -> ComputerStreamingConfig {
        ::std::default::Default::default()
    }

    // bool activated = 1;


    pub fn get_activated(&self) -> bool {
        self.activated
    }
    pub fn clear_activated(&mut self) {
        self.activated = false;
    }

    // Param is passed by value, moved
    pub fn set_activated(&mut self, v: bool) {
        self.activated = v;
    }

    // string camera = 2;


    pub fn get_camera(&self) -> &str {
        &self.camera
    }
    pub fn clear_camera(&mut self) {
        self.camera.clear();
    }

    // Param is passed by value, moved
    pub fn set_camera(&mut self, v: ::std::string::String) {
        self.camera = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera(&mut self) -> &mut ::std::string::String {
        &mut self.camera
    }

    // Take field
    pub fn take_camera(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.camera, ::std::string::String::new())
    }

    // .PhoneStreamingOutput output = 3;


    pub fn get_output(&self) -> PhoneStreamingOutput {
        self.output
    }
    pub fn clear_output(&mut self) {
        self.output = PhoneStreamingOutput::STREAM;
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: PhoneStreamingOutput) {
        self.output = v;
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // repeated string arguments = 5;


    pub fn get_arguments(&self) -> &[::std::string::String] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ComputerStreamingConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.activated = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.camera)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.output, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.arguments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.activated != false {
            my_size += 2;
        }
        if !self.camera.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.camera);
        }
        if self.output != PhoneStreamingOutput::STREAM {
            my_size += ::protobuf::rt::enum_size(3, self.output);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.activated != false {
            os.write_bool(1, self.activated)?;
        }
        if !self.camera.is_empty() {
            os.write_string(2, &self.camera)?;
        }
        if self.output != PhoneStreamingOutput::STREAM {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.output))?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        for v in &self.arguments {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputerStreamingConfig {
        ComputerStreamingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "activated",
                |m: &ComputerStreamingConfig| { &m.activated },
                |m: &mut ComputerStreamingConfig| { &mut m.activated },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "camera",
                |m: &ComputerStreamingConfig| { &m.camera },
                |m: &mut ComputerStreamingConfig| { &mut m.camera },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PhoneStreamingOutput>>(
                "output",
                |m: &ComputerStreamingConfig| { &m.output },
                |m: &mut ComputerStreamingConfig| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &ComputerStreamingConfig| { &m.url },
                |m: &mut ComputerStreamingConfig| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "arguments",
                |m: &ComputerStreamingConfig| { &m.arguments },
                |m: &mut ComputerStreamingConfig| { &mut m.arguments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputerStreamingConfig>(
                "ComputerStreamingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputerStreamingConfig {
        static instance: ::protobuf::rt::LazyV2<ComputerStreamingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputerStreamingConfig::new)
    }
}

impl ::protobuf::Clear for ComputerStreamingConfig {
    fn clear(&mut self) {
        self.activated = false;
        self.camera.clear();
        self.output = PhoneStreamingOutput::STREAM;
        self.url.clear();
        self.arguments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputerStreamingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputerStreamingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputerStreamingState {
    // message fields
    pub cameras: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputerStreamingState {
    fn default() -> &'a ComputerStreamingState {
        <ComputerStreamingState as ::protobuf::Message>::default_instance()
    }
}

impl ComputerStreamingState {
    pub fn new() -> ComputerStreamingState {
        ::std::default::Default::default()
    }

    // repeated string cameras = 1;


    pub fn get_cameras(&self) -> &[::std::string::String] {
        &self.cameras
    }
    pub fn clear_cameras(&mut self) {
        self.cameras.clear();
    }

    // Param is passed by value, moved
    pub fn set_cameras(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cameras = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cameras(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cameras
    }

    // Take field
    pub fn take_cameras(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cameras, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ComputerStreamingState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cameras)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cameras {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cameras {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputerStreamingState {
        ComputerStreamingState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cameras",
                |m: &ComputerStreamingState| { &m.cameras },
                |m: &mut ComputerStreamingState| { &mut m.cameras },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputerStreamingState>(
                "ComputerStreamingState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputerStreamingState {
        static instance: ::protobuf::rt::LazyV2<ComputerStreamingState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputerStreamingState::new)
    }
}

impl ::protobuf::Clear for ComputerStreamingState {
    fn clear(&mut self) {
        self.cameras.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputerStreamingState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputerStreamingState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActorType {
    MANUAL_USER_ACTOR = 0,
    DURATION_ACTOR = 1,
    ALARM_ACTOR = 2,
    VIRTUAL_ACTOR = 3,
}

impl ::protobuf::ProtobufEnum for ActorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActorType> {
        match value {
            0 => ::std::option::Option::Some(ActorType::MANUAL_USER_ACTOR),
            1 => ::std::option::Option::Some(ActorType::DURATION_ACTOR),
            2 => ::std::option::Option::Some(ActorType::ALARM_ACTOR),
            3 => ::std::option::Option::Some(ActorType::VIRTUAL_ACTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActorType] = &[
            ActorType::MANUAL_USER_ACTOR,
            ActorType::DURATION_ACTOR,
            ActorType::ALARM_ACTOR,
            ActorType::VIRTUAL_ACTOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActorType>("ActorType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActorType {
}

impl ::std::default::Default for ActorType {
    fn default() -> Self {
        ActorType::MANUAL_USER_ACTOR
    }
}

impl ::protobuf::reflect::ProtobufValue for ActorType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CalibrationStep {
    READY_CALIBRATION = 0,
    LOW_CALIBRATION = 1,
    HIGH_CALIBRATION = 2,
    ERROR_CALIBRATION = 3,
    WAITING_CONFIRMATION_CALIBRATION = 4,
}

impl ::protobuf::ProtobufEnum for CalibrationStep {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalibrationStep> {
        match value {
            0 => ::std::option::Option::Some(CalibrationStep::READY_CALIBRATION),
            1 => ::std::option::Option::Some(CalibrationStep::LOW_CALIBRATION),
            2 => ::std::option::Option::Some(CalibrationStep::HIGH_CALIBRATION),
            3 => ::std::option::Option::Some(CalibrationStep::ERROR_CALIBRATION),
            4 => ::std::option::Option::Some(CalibrationStep::WAITING_CONFIRMATION_CALIBRATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CalibrationStep] = &[
            CalibrationStep::READY_CALIBRATION,
            CalibrationStep::LOW_CALIBRATION,
            CalibrationStep::HIGH_CALIBRATION,
            CalibrationStep::ERROR_CALIBRATION,
            CalibrationStep::WAITING_CONFIRMATION_CALIBRATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CalibrationStep>("CalibrationStep", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CalibrationStep {
}

impl ::std::default::Default for CalibrationStep {
    fn default() -> Self {
        CalibrationStep::READY_CALIBRATION
    }
}

impl ::protobuf::reflect::ProtobufValue for CalibrationStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CalibrationStepStatus {
    INSUFFISANT_DATA_STATUS = 0,
    ENOUGHT_DATA_STATUS = 1,
    ERROR_STATUS = 2,
    AWAITING_STEP_STATUS = 3,
}

impl ::protobuf::ProtobufEnum for CalibrationStepStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalibrationStepStatus> {
        match value {
            0 => ::std::option::Option::Some(CalibrationStepStatus::INSUFFISANT_DATA_STATUS),
            1 => ::std::option::Option::Some(CalibrationStepStatus::ENOUGHT_DATA_STATUS),
            2 => ::std::option::Option::Some(CalibrationStepStatus::ERROR_STATUS),
            3 => ::std::option::Option::Some(CalibrationStepStatus::AWAITING_STEP_STATUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CalibrationStepStatus] = &[
            CalibrationStepStatus::INSUFFISANT_DATA_STATUS,
            CalibrationStepStatus::ENOUGHT_DATA_STATUS,
            CalibrationStepStatus::ERROR_STATUS,
            CalibrationStepStatus::AWAITING_STEP_STATUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CalibrationStepStatus>("CalibrationStepStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CalibrationStepStatus {
}

impl ::std::default::Default for CalibrationStepStatus {
    fn default() -> Self {
        CalibrationStepStatus::INSUFFISANT_DATA_STATUS
    }
}

impl ::protobuf::reflect::ProtobufValue for CalibrationStepStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CalibrationError {
    NONE_ERROR = 0,
    ALREADY_STARTED_ERROR = 1,
    INSTABLE_DATA_ERROR = 2,
    NOT_ENOUGHT_DATA_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for CalibrationError {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CalibrationError> {
        match value {
            0 => ::std::option::Option::Some(CalibrationError::NONE_ERROR),
            1 => ::std::option::Option::Some(CalibrationError::ALREADY_STARTED_ERROR),
            2 => ::std::option::Option::Some(CalibrationError::INSTABLE_DATA_ERROR),
            3 => ::std::option::Option::Some(CalibrationError::NOT_ENOUGHT_DATA_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CalibrationError] = &[
            CalibrationError::NONE_ERROR,
            CalibrationError::ALREADY_STARTED_ERROR,
            CalibrationError::INSTABLE_DATA_ERROR,
            CalibrationError::NOT_ENOUGHT_DATA_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CalibrationError>("CalibrationError", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CalibrationError {
}

impl ::std::default::Default for CalibrationError {
    fn default() -> Self {
        CalibrationError::NONE_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for CalibrationError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RelayOutletMode {
    MANUAL = 0,
    ALARM = 1,
    VIRTUAL = 2,
    CYCLE = 3,
}

impl ::protobuf::ProtobufEnum for RelayOutletMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RelayOutletMode> {
        match value {
            0 => ::std::option::Option::Some(RelayOutletMode::MANUAL),
            1 => ::std::option::Option::Some(RelayOutletMode::ALARM),
            2 => ::std::option::Option::Some(RelayOutletMode::VIRTUAL),
            3 => ::std::option::Option::Some(RelayOutletMode::CYCLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RelayOutletMode] = &[
            RelayOutletMode::MANUAL,
            RelayOutletMode::ALARM,
            RelayOutletMode::VIRTUAL,
            RelayOutletMode::CYCLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RelayOutletMode>("RelayOutletMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RelayOutletMode {
}

impl ::std::default::Default for RelayOutletMode {
    fn default() -> Self {
        RelayOutletMode::MANUAL
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayOutletMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PhoneStreamingStatus {
    STOPPED = 0,
    RUNNING = 1,
    ERROR = 2,
}

impl ::protobuf::ProtobufEnum for PhoneStreamingStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhoneStreamingStatus> {
        match value {
            0 => ::std::option::Option::Some(PhoneStreamingStatus::STOPPED),
            1 => ::std::option::Option::Some(PhoneStreamingStatus::RUNNING),
            2 => ::std::option::Option::Some(PhoneStreamingStatus::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PhoneStreamingStatus] = &[
            PhoneStreamingStatus::STOPPED,
            PhoneStreamingStatus::RUNNING,
            PhoneStreamingStatus::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PhoneStreamingStatus>("PhoneStreamingStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PhoneStreamingStatus {
}

impl ::std::default::Default for PhoneStreamingStatus {
    fn default() -> Self {
        PhoneStreamingStatus::STOPPED
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStreamingStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PhoneStreamingCamera {
    BACK = 0,
    FRONT = 1,
}

impl ::protobuf::ProtobufEnum for PhoneStreamingCamera {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhoneStreamingCamera> {
        match value {
            0 => ::std::option::Option::Some(PhoneStreamingCamera::BACK),
            1 => ::std::option::Option::Some(PhoneStreamingCamera::FRONT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PhoneStreamingCamera] = &[
            PhoneStreamingCamera::BACK,
            PhoneStreamingCamera::FRONT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PhoneStreamingCamera>("PhoneStreamingCamera", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PhoneStreamingCamera {
}

impl ::std::default::Default for PhoneStreamingCamera {
    fn default() -> Self {
        PhoneStreamingCamera::BACK
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStreamingCamera {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PhoneStreamingOutput {
    STREAM = 0,
    RECORD = 1,
    STREAM_N_RECORD = 2,
}

impl ::protobuf::ProtobufEnum for PhoneStreamingOutput {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PhoneStreamingOutput> {
        match value {
            0 => ::std::option::Option::Some(PhoneStreamingOutput::STREAM),
            1 => ::std::option::Option::Some(PhoneStreamingOutput::RECORD),
            2 => ::std::option::Option::Some(PhoneStreamingOutput::STREAM_N_RECORD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PhoneStreamingOutput] = &[
            PhoneStreamingOutput::STREAM,
            PhoneStreamingOutput::RECORD,
            PhoneStreamingOutput::STREAM_N_RECORD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PhoneStreamingOutput>("PhoneStreamingOutput", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PhoneStreamingOutput {
}

impl ::std::default::Default for PhoneStreamingOutput {
    fn default() -> Self {
        PhoneStreamingOutput::STREAM
    }
}

impl ::protobuf::reflect::ProtobufValue for PhoneStreamingOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cmodule.proto\"K\n\x05Actor\x12\x1e\n\x04type\x18\x01\x20\x01(\x0e2\
    \n.ActorTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x12\
    \n\x04name\x18\x03\x20\x01(\tR\x04name\"H\n\x0eActorOwnership\x12\x1a\n\
    \x08moduleId\x18\x01\x20\x01(\tR\x08moduleId\x12\x1a\n\x08property\x18\
    \x02\x20\x01(\tR\x08property\"c\n\x12ActorWithOwnership\x12\x1c\n\x05act\
    or\x18\x01\x20\x01(\x0b2\x06.ActorR\x05actor\x12/\n\nownerships\x18\x02\
    \x20\x03(\x0b2\x0f.ActorOwnershipR\nownerships\"\xd4\x01\n\nModuleData\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x1c\n\treadCount\x18\x04\x20\x01(\x05R\treadCount\
    \x12\"\n\x0cboardVersion\x18\x05\x20\x01(\tR\x0cboardVersion\x12\x12\n\
    \x04plug\x18\x06\x20\x01(\x08R\x04plug\x12\x18\n\x07atIndex\x18\x07\x20\
    \x01(\x05R\x07atIndex\x12\x14\n\x05board\x18\x08\x20\x01(\tR\x05board\
    \x12\x1c\n\tboardAddr\x18\t\x20\x01(\tR\tboardAddr\"q\n\rTHLModuleData\
    \x12\x1a\n\x08humidity\x18\x02\x20\x01(\x02R\x08humidity\x12&\n\x0eairTe\
    mperature\x18\x03\x20\x01(\x02R\x0eairTemperature\x12\x1c\n\ttimestamp\
    \x18\t\x20\x01(\x05R\ttimestamp\"\xcc\x01\n\x0eSOILModuleData\x12\x0e\n\
    \x02p0\x18\x01\x20\x01(\x05R\x02p0\x12\x0e\n\x02p1\x18\x02\x20\x01(\x05R\
    \x02p1\x12\x0e\n\x02p2\x18\x03\x20\x01(\x05R\x02p2\x12\x0e\n\x02p3\x18\
    \x04\x20\x01(\x05R\x02p3\x12\x0e\n\x02p4\x18\x05\x20\x01(\x05R\x02p4\x12\
    \x0e\n\x02p5\x18\x06\x20\x01(\x05R\x02p5\x12\x0e\n\x02p6\x18\x07\x20\x01\
    (\x05R\x02p6\x12\x0e\n\x02p7\x18\x08\x20\x01(\x05R\x02p7\x12\x1c\n\ttime\
    stamp\x18\t\x20\x01(\x05R\ttimestamp\x12\x1c\n\tvaluetype\x18\n\x20\x01(\
    \tR\tvaluetype\"7\n\x0fSOILProbeConfig\x12\x10\n\x03low\x18\x01\x20\x01(\
    \x05R\x03low\x12\x12\n\x04high\x18\x02\x20\x01(\x05R\x04high\"\xa2\x02\n\
    \x10SOILModuleConfig\x12\x20\n\x02p0\x18\x01\x20\x01(\x0b2\x10.SOILProbe\
    ConfigR\x02p0\x12\x20\n\x02p1\x18\x02\x20\x01(\x0b2\x10.SOILProbeConfigR\
    \x02p1\x12\x20\n\x02p2\x18\x03\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p2\
    \x12\x20\n\x02p3\x18\x04\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p3\x12\
    \x20\n\x02p4\x18\x05\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p4\x12\x20\n\
    \x02p5\x18\x06\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p5\x12\x20\n\x02p6\
    \x18\x07\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p6\x12\x20\n\x02p7\x18\
    \x08\x20\x01(\x0b2\x10.SOILProbeConfigR\x02p7\"\x16\n\x14SOILCalibration\
    Start\"N\n\x13SOILCalibrationStep\x127\n\x0erequested_step\x18\x01\x20\
    \x01(\x0e2\x10.CalibrationStepR\rrequestedStep\"\xf7\x01\n\x18SOILCalibr\
    ationStepEvent\x12$\n\x04step\x18\x01\x20\x01(\x0e2\x10.CalibrationStepR\
    \x04step\x12.\n\x06status\x18\x02\x20\x01(\x0e2\x16.CalibrationStepStatu\
    sR\x06status\x12%\n\x04erro\x18\x03\x20\x01(\x0e2\x11.CalibrationErrorR\
    \x04erro\x12\x16\n\x06messag\x18\x04\x20\x01(\tR\x06messag\x12!\n\x03low\
    \x18\x05\x20\x03(\x0b2\x0f.SOILModuleDataR\x03low\x12#\n\x04high\x18\x06\
    \x20\x03(\x0b2\x0f.SOILModuleDataR\x04high\"n\n\x0cWAModuleData\x12\x0e\
    \n\x02PH\x18\x02\x20\x01(\x05R\x02PH\x12\x0e\n\x02EC\x18\x03\x20\x01(\
    \x05R\x02EC\x12\x20\n\x0btemperature\x18\x04\x20\x01(\x05R\x0btemperatur\
    e\x12\x1c\n\ttimestamp\x18\t\x20\x01(\x05R\ttimestamp\"\x82\x01\n\x08Cro\
    nItem\x12\x16\n\x06minute\x18\x01\x20\x01(\x05R\x06minute\x12\x12\n\x04h\
    our\x18\x02\x20\x01(\x05R\x04hour\x12\x1a\n\x08dayMonth\x18\x03\x20\x01(\
    \x05R\x08dayMonth\x12\x14\n\x05month\x18\x04\x20\x01(\x05R\x05month\x12\
    \x18\n\x07dayWeek\x18\x05\x20\x01(\x05R\x07dayWeek\"Q\n\x0bCycleConfig\
    \x12\x20\n\x0bwaitingTime\x18\x01\x20\x01(\x05R\x0bwaitingTime\x12\x20\n\
    \x0brunningTime\x18\x02\x20\x01(\x05R\x0brunningTime\"Q\n\x0bAlarmConfig\
    \x12%\n\x08begining\x18\x01\x20\x01(\x0b2\t.CronItemR\x08begining\x12\
    \x1b\n\x03end\x18\x02\x20\x01(\x0b2\t.CronItemR\x03end\"@\n\x0cManualCon\
    fig\x12\x14\n\x05state\x18\x01\x20\x01(\x08R\x05state\x12\x1a\n\x08durat\
    ion\x18\x02\x20\x01(\x05R\x08duration\"'\n\x0fRelayOutletData\x12\x14\n\
    \x05state\x18\x01\x20\x01(\x08R\x05state\"\x14\n\x12VirtualRelayConfig\"\
    \xd7\x01\n\x11RelayOutletConfig\x12$\n\x04mode\x18\x01\x20\x01(\x0e2\x10\
    .RelayOutletModeR\x04mode\x12\"\n\x05alarm\x18\x02\x20\x01(\x0b2\x0c.Ala\
    rmConfigR\x05alarm\x12%\n\x06manual\x18\x03\x20\x01(\x0b2\r.ManualConfig\
    R\x06manual\x12-\n\x07virtual\x18\x04\x20\x01(\x0b2\x13.VirtualRelayConf\
    igR\x07virtual\x12\"\n\x05cycle\x18\x05\x20\x01(\x0b2\x0c.CycleConfigR\
    \x05cycle\"v\n\x1aVirtualRelayPropertyConfig\x12\x1a\n\x08property\x18\
    \x01\x20\x01(\x05R\x08property\x12\x1e\n\nfalseState\x18\x02\x20\x01(\
    \x08R\nfalseState\x12\x1c\n\ttrueState\x18\x03\x20\x01(\x08R\ttrueState\
    \"O\n\x10VirtualRelayItem\x12;\n\nproperties\x18\x01\x20\x03(\x0b2\x1b.V\
    irtualRelayPropertyConfigR\nproperties\"\xa3\x01\n\x0cVirtualRelay\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x121\n\x06relays\x18\x02\x20\
    \x03(\x0b2\x19.VirtualRelay.RelaysEntryR\x06relays\x1aL\n\x0bRelaysEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12'\n\x05value\x18\x02\x20\
    \x01(\x0b2\x11.VirtualRelayItemR\x05value:\x028\x01\"6\n\rVirtualRelays\
    \x12%\n\x06relays\x18\x01\x20\x03(\x0b2\r.VirtualRelayR\x06relays\"V\n\
    \x10VirtualRelayData\x12$\n\x04data\x18\x01\x20\x01(\x0b2\x10.RelayOutle\
    tDataR\x04data\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x05R\ttimestamp\"S\
    \n\x11VirtualRelayState\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\
    \x14\n\x05state\x18\x02\x20\x01(\x08R\x05state\x12\x18\n\x07message\x18\
    \x03\x20\x01(\tR\x07message\"\xdd\x02\n\x0fRelayModuleData\x12\x20\n\x02\
    p0\x18\x01\x20\x01(\x0b2\x10.RelayOutletDataR\x02p0\x12\x20\n\x02p1\x18\
    \x02\x20\x01(\x0b2\x10.RelayOutletDataR\x02p1\x12\x20\n\x02p2\x18\x03\
    \x20\x01(\x0b2\x10.RelayOutletDataR\x02p2\x12\x20\n\x02p3\x18\x04\x20\
    \x01(\x0b2\x10.RelayOutletDataR\x02p3\x12\x20\n\x02p4\x18\x05\x20\x01(\
    \x0b2\x10.RelayOutletDataR\x02p4\x12\x20\n\x02p5\x18\x06\x20\x01(\x0b2\
    \x10.RelayOutletDataR\x02p5\x12\x20\n\x02p6\x18\x07\x20\x01(\x0b2\x10.Re\
    layOutletDataR\x02p6\x12\x20\n\x02p7\x18\x08\x20\x01(\x0b2\x10.RelayOutl\
    etDataR\x02p7\x12\x1c\n\ttimestamp\x18\t\x20\x01(\x05R\ttimestamp\x12\
    \x1c\n\x05actor\x18\n\x20\x01(\x0b2\x06.ActorR\x05actor\"\xd1\x02\n\x11R\
    elayModuleConfig\x12\"\n\x02p0\x18\x01\x20\x01(\x0b2\x12.RelayOutletConf\
    igR\x02p0\x12\"\n\x02p1\x18\x02\x20\x01(\x0b2\x12.RelayOutletConfigR\x02\
    p1\x12\"\n\x02p2\x18\x03\x20\x01(\x0b2\x12.RelayOutletConfigR\x02p2\x12\
    \"\n\x02p3\x18\x04\x20\x01(\x0b2\x12.RelayOutletConfigR\x02p3\x12\"\n\
    \x02p4\x18\x05\x20\x01(\x0b2\x12.RelayOutletConfigR\x02p4\x12\"\n\x02p5\
    \x18\x06\x20\x01(\x0b2\x12.RelayOutletConfigR\x02p5\x12\"\n\x02p6\x18\
    \x07\x20\x01(\x0b2\x12.RelayOutletConfigR\x02p6\x12\"\n\x02p7\x18\x08\
    \x20\x01(\x0b2\x12.RelayOutletConfigR\x02p7\x12\x1c\n\ttimestamp\x18\t\
    \x20\x01(\x05R\ttimestamp\"\xf8\x02\n\x0cWCModuleData\x12\x20\n\x02p0\
    \x18\x01\x20\x01(\x0b2\x10.RelayOutletDataR\x02p0\x12\x20\n\x02p1\x18\
    \x02\x20\x01(\x0b2\x10.RelayOutletDataR\x02p1\x12\x20\n\x02p2\x18\x03\
    \x20\x01(\x0b2\x10.RelayOutletDataR\x02p2\x12&\n\x05drain\x18\x04\x20\
    \x01(\x0b2\x10.RelayOutletDataR\x05drain\x12&\n\x05pump0\x18\x05\x20\x01\
    (\x0b2\x10.RelayOutletDataR\x05pump0\x12&\n\x05pump1\x18\x06\x20\x01(\
    \x0b2\x10.RelayOutletDataR\x05pump1\x12&\n\x05pump2\x18\x07\x20\x01(\x0b\
    2\x10.RelayOutletDataR\x05pump2\x12&\n\x05pump3\x18\x08\x20\x01(\x0b2\
    \x10.RelayOutletDataR\x05pump3\x12\x1c\n\ttimestamp\x18\t\x20\x01(\x05R\
    \ttimestamp\x12\x1c\n\x05actor\x18\n\x20\x01(\x0b2\x06.ActorR\x05actor\"\
    \xce\x02\n\x0eWCModuleConfig\x12\"\n\x02p0\x18\x01\x20\x01(\x0b2\x12.Rel\
    ayOutletConfigR\x02p0\x12\"\n\x02p1\x18\x02\x20\x01(\x0b2\x12.RelayOutle\
    tConfigR\x02p1\x12\"\n\x02p2\x18\x03\x20\x01(\x0b2\x12.RelayOutletConfig\
    R\x02p2\x12(\n\x05drain\x18\x04\x20\x01(\x0b2\x12.RelayOutletConfigR\x05\
    drain\x12(\n\x05pump0\x18\x05\x20\x01(\x0b2\x12.RelayOutletConfigR\x05pu\
    mp0\x12(\n\x05pump1\x18\x06\x20\x01(\x0b2\x12.RelayOutletConfigR\x05pump\
    1\x12(\n\x05pump2\x18\x07\x20\x01(\x0b2\x12.RelayOutletConfigR\x05pump2\
    \x12(\n\x05pump3\x18\x08\x20\x01(\x0b2\x12.RelayOutletConfigR\x05pump3\"\
    \x9f\x01\n\x11PhonePositionData\x12\x10\n\x03lat\x18\x01\x20\x01(\x02R\
    \x03lat\x12\x10\n\x03log\x18\x02\x20\x01(\x02R\x03log\x12\x1a\n\x08accur\
    acy\x18\x03\x20\x01(\x02R\x08accuracy\x12\x1a\n\x08altitude\x18\x04\x20\
    \x01(\x01R\x08altitude\x12\x18\n\x07bearing\x18\x05\x20\x01(\x02R\x07bea\
    ring\x12\x14\n\x05speed\x18\x07\x20\x01(\x02R\x05speed\"\x15\n\x13PhoneP\
    ositionConfig\"G\n\x15PhoneAccelerationData\x12\x0e\n\x02gx\x18\x01\x20\
    \x01(\x02R\x02gx\x12\x0e\n\x02gy\x18\x02\x20\x01(\x02R\x02gy\x12\x0e\n\
    \x02gz\x18\x03\x20\x01(\x02R\x02gz\"\x19\n\x17PhoneAccelerationConfig\".\
    \n\x15PhoneAmbientLightData\x12\x15\n\x06si_lux\x18\x01\x20\x01(\x02R\
    \x05siLux\"\x19\n\x17PhoneAmbientLightConfig\"%\n\x11PhonePressureData\
    \x12\x10\n\x03hpa\x18\x01\x20\x01(\x02R\x03hpa\"\x15\n\x13PhonePressureC\
    onfig\"#\n\x05Point\x12\x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x01(\x05R\x01y\"Z\n\x04Rect\x12\x10\n\x03top\x18\x01\
    \x20\x01(\x05R\x03top\x12\x14\n\x05right\x18\x02\x20\x01(\x05R\x05right\
    \x12\x16\n\x06bottom\x18\x03\x20\x01(\x05R\x06bottom\x12\x12\n\x04left\
    \x18\x04\x20\x01(\x05R\x04left\"\xb1\x01\n\nCameraFace\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x14\n\x05score\x18\x02\x20\x01(\x05R\
    \x05score\x12\x19\n\x04rect\x18\x03\x20\x01(\x0b2\x05.RectR\x04rect\x12\
    \x1c\n\x05mouth\x18\x04\x20\x01(\x0b2\x06.PointR\x05mouth\x12\x20\n\x07l\
    eftEye\x18\x05\x20\x01(\x0b2\x06.PointR\x07leftEye\x12\"\n\x08rightEye\
    \x18\x06\x20\x01(\x0b2\x06.PointR\x08rightEye\"\xa8\x01\n\x12PhoneStream\
    ingData\x12-\n\x06status\x18\x01\x20\x01(\x0e2\x15.PhoneStreamingStatusR\
    \x06status\x12\x10\n\x03fps\x18\x02\x20\x01(\x02R\x03fps\x12\x18\n\x07bi\
    trate\x18\x03\x20\x01(\x02R\x07bitrate\x12!\n\x05faces\x18\x04\x20\x03(\
    \x0b2\x0b.CameraFaceR\x05faces\x12\x14\n\x05error\x18\x05\x20\x01(\tR\
    \x05error\"\xce\x02\n\x14PhoneStreamingConfig\x12\x1c\n\tactivated\x18\
    \x01\x20\x01(\x08R\tactivated\x12-\n\x06output\x18\x02\x20\x01(\x0e2\x15\
    .PhoneStreamingOutputR\x06output\x12\x10\n\x03url\x18\x03\x20\x01(\tR\
    \x03url\x12-\n\x06camera\x18\x04\x20\x01(\x0e2\x15.PhoneStreamingCameraR\
    \x06camera\x12\x14\n\x05light\x18\x05\x20\x01(\x08R\x05light\x12\x14\n\
    \x05audio\x18\x06\x20\x01(\x08R\x05audio\x12\x1c\n\tautoFocus\x18\x07\
    \x20\x01(\x08R\tautoFocus\x12$\n\rstabilization\x18\x08\x20\x01(\x08R\rs\
    tabilization\x12$\n\rfaceDetection\x18\t\x20\x01(\x08R\rfaceDetection\
    \x12\x12\n\x04zoom\x18\n\x20\x01(\x05R\x04zoom\"\x88\x01\n\x15ComputerSt\
    reamingData\x12-\n\x06status\x18\x01\x20\x01(\x0e2\x15.PhoneStreamingSta\
    tusR\x06status\x12\x10\n\x03fps\x18\x02\x20\x01(\x02R\x03fps\x12\x18\n\
    \x07bitrate\x18\x03\x20\x01(\x02R\x07bitrate\x12\x14\n\x05error\x18\x04\
    \x20\x01(\tR\x05error\"\xae\x01\n\x17ComputerStreamingConfig\x12\x1c\n\t\
    activated\x18\x01\x20\x01(\x08R\tactivated\x12\x16\n\x06camera\x18\x02\
    \x20\x01(\tR\x06camera\x12-\n\x06output\x18\x03\x20\x01(\x0e2\x15.PhoneS\
    treamingOutputR\x06output\x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\
    \x12\x1c\n\targuments\x18\x05\x20\x03(\tR\targuments\"2\n\x16ComputerStr\
    eamingState\x12\x18\n\x07cameras\x18\x01\x20\x03(\tR\x07cameras*Z\n\tAct\
    orType\x12\x15\n\x11MANUAL_USER_ACTOR\x10\0\x12\x12\n\x0eDURATION_ACTOR\
    \x10\x01\x12\x0f\n\x0bALARM_ACTOR\x10\x02\x12\x11\n\rVIRTUAL_ACTOR\x10\
    \x03*\x90\x01\n\x0fCalibrationStep\x12\x15\n\x11READY_CALIBRATION\x10\0\
    \x12\x13\n\x0fLOW_CALIBRATION\x10\x01\x12\x14\n\x10HIGH_CALIBRATION\x10\
    \x02\x12\x15\n\x11ERROR_CALIBRATION\x10\x03\x12$\n\x20WAITING_CONFIRMATI\
    ON_CALIBRATION\x10\x04*y\n\x15CalibrationStepStatus\x12\x1b\n\x17INSUFFI\
    SANT_DATA_STATUS\x10\0\x12\x17\n\x13ENOUGHT_DATA_STATUS\x10\x01\x12\x10\
    \n\x0cERROR_STATUS\x10\x02\x12\x18\n\x14AWAITING_STEP_STATUS\x10\x03*r\n\
    \x10CalibrationError\x12\x0e\n\nNONE_ERROR\x10\0\x12\x19\n\x15ALREADY_ST\
    ARTED_ERROR\x10\x01\x12\x17\n\x13INSTABLE_DATA_ERROR\x10\x02\x12\x1a\n\
    \x16NOT_ENOUGHT_DATA_ERROR\x10\x03*@\n\x0fRelayOutletMode\x12\n\n\x06MAN\
    UAL\x10\0\x12\t\n\x05ALARM\x10\x01\x12\x0b\n\x07VIRTUAL\x10\x02\x12\t\n\
    \x05CYCLE\x10\x03*;\n\x14PhoneStreamingStatus\x12\x0b\n\x07STOPPED\x10\0\
    \x12\x0b\n\x07RUNNING\x10\x01\x12\t\n\x05ERROR\x10\x02*+\n\x14PhoneStrea\
    mingCamera\x12\x08\n\x04BACK\x10\0\x12\t\n\x05FRONT\x10\x01*C\n\x14Phone\
    StreamingOutput\x12\n\n\x06STREAM\x10\0\x12\n\n\x06RECORD\x10\x01\x12\
    \x13\n\x0fSTREAM_N_RECORD\x10\x02B+\n)ca.berlingoqc.growbe_android_modul\
    e.protob\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
