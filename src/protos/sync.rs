// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `sync.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct SyncInfo {
    // message fields
    pub hash: ::std::string::String,
    pub updatedAt: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncInfo {
    fn default() -> &'a SyncInfo {
        <SyncInfo as ::protobuf::Message>::default_instance()
    }
}

impl SyncInfo {
    pub fn new() -> SyncInfo {
        ::std::default::Default::default()
    }

    // string hash = 1;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // uint32 updatedAt = 2;


    pub fn get_updatedAt(&self) -> u32 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: u32) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for SyncInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.hash);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_string(1, &self.hash)?;
        }
        if self.updatedAt != 0 {
            os.write_uint32(2, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncInfo {
        SyncInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &SyncInfo| { &m.hash },
                |m: &mut SyncInfo| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "updatedAt",
                |m: &SyncInfo| { &m.updatedAt },
                |m: &mut SyncInfo| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncInfo>(
                "SyncInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncInfo {
        static instance: ::protobuf::rt::LazyV2<SyncInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncInfo::new)
    }
}

impl ::protobuf::Clear for SyncInfo {
    fn clear(&mut self) {
        self.hash.clear();
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalSyncInformation {
    // message fields
    pub syncItems: ::std::collections::HashMap<::std::string::String, SyncInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalSyncInformation {
    fn default() -> &'a GlobalSyncInformation {
        <GlobalSyncInformation as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSyncInformation {
    pub fn new() -> GlobalSyncInformation {
        ::std::default::Default::default()
    }

    // repeated .GlobalSyncInformation.SyncItemsEntry syncItems = 1;


    pub fn get_syncItems(&self) -> &::std::collections::HashMap<::std::string::String, SyncInfo> {
        &self.syncItems
    }
    pub fn clear_syncItems(&mut self) {
        self.syncItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_syncItems(&mut self, v: ::std::collections::HashMap<::std::string::String, SyncInfo>) {
        self.syncItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_syncItems(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SyncInfo> {
        &mut self.syncItems
    }

    // Take field
    pub fn take_syncItems(&mut self) -> ::std::collections::HashMap<::std::string::String, SyncInfo> {
        ::std::mem::replace(&mut self.syncItems, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for GlobalSyncInformation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(wire_type, is, &mut self.syncItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(1, &self.syncItems);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(1, &self.syncItems, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalSyncInformation {
        GlobalSyncInformation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(
                "syncItems",
                |m: &GlobalSyncInformation| { &m.syncItems },
                |m: &mut GlobalSyncInformation| { &mut m.syncItems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalSyncInformation>(
                "GlobalSyncInformation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalSyncInformation {
        static instance: ::protobuf::rt::LazyV2<GlobalSyncInformation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalSyncInformation::new)
    }
}

impl ::protobuf::Clear for GlobalSyncInformation {
    fn clear(&mut self) {
        self.syncItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalSyncInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSyncInformation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutOfSyncItem {
    // message fields
    pub ressource: ::std::string::String,
    pub mainboard: ::protobuf::SingularPtrField<SyncInfo>,
    pub cloud: ::protobuf::SingularPtrField<SyncInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutOfSyncItem {
    fn default() -> &'a OutOfSyncItem {
        <OutOfSyncItem as ::protobuf::Message>::default_instance()
    }
}

impl OutOfSyncItem {
    pub fn new() -> OutOfSyncItem {
        ::std::default::Default::default()
    }

    // string ressource = 1;


    pub fn get_ressource(&self) -> &str {
        &self.ressource
    }
    pub fn clear_ressource(&mut self) {
        self.ressource.clear();
    }

    // Param is passed by value, moved
    pub fn set_ressource(&mut self, v: ::std::string::String) {
        self.ressource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ressource(&mut self) -> &mut ::std::string::String {
        &mut self.ressource
    }

    // Take field
    pub fn take_ressource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ressource, ::std::string::String::new())
    }

    // .SyncInfo mainboard = 2;


    pub fn get_mainboard(&self) -> &SyncInfo {
        self.mainboard.as_ref().unwrap_or_else(|| <SyncInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mainboard(&mut self) {
        self.mainboard.clear();
    }

    pub fn has_mainboard(&self) -> bool {
        self.mainboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mainboard(&mut self, v: SyncInfo) {
        self.mainboard = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mainboard(&mut self) -> &mut SyncInfo {
        if self.mainboard.is_none() {
            self.mainboard.set_default();
        }
        self.mainboard.as_mut().unwrap()
    }

    // Take field
    pub fn take_mainboard(&mut self) -> SyncInfo {
        self.mainboard.take().unwrap_or_else(|| SyncInfo::new())
    }

    // .SyncInfo cloud = 3;


    pub fn get_cloud(&self) -> &SyncInfo {
        self.cloud.as_ref().unwrap_or_else(|| <SyncInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cloud(&mut self) {
        self.cloud.clear();
    }

    pub fn has_cloud(&self) -> bool {
        self.cloud.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud(&mut self, v: SyncInfo) {
        self.cloud = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud(&mut self) -> &mut SyncInfo {
        if self.cloud.is_none() {
            self.cloud.set_default();
        }
        self.cloud.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud(&mut self) -> SyncInfo {
        self.cloud.take().unwrap_or_else(|| SyncInfo::new())
    }
}

impl ::protobuf::Message for OutOfSyncItem {
    fn is_initialized(&self) -> bool {
        for v in &self.mainboard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloud {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ressource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mainboard)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ressource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ressource);
        }
        if let Some(ref v) = self.mainboard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloud.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ressource.is_empty() {
            os.write_string(1, &self.ressource)?;
        }
        if let Some(ref v) = self.mainboard.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloud.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutOfSyncItem {
        OutOfSyncItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ressource",
                |m: &OutOfSyncItem| { &m.ressource },
                |m: &mut OutOfSyncItem| { &mut m.ressource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(
                "mainboard",
                |m: &OutOfSyncItem| { &m.mainboard },
                |m: &mut OutOfSyncItem| { &mut m.mainboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(
                "cloud",
                |m: &OutOfSyncItem| { &m.cloud },
                |m: &mut OutOfSyncItem| { &mut m.cloud },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutOfSyncItem>(
                "OutOfSyncItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutOfSyncItem {
        static instance: ::protobuf::rt::LazyV2<OutOfSyncItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutOfSyncItem::new)
    }
}

impl ::protobuf::Clear for OutOfSyncItem {
    fn clear(&mut self) {
        self.ressource.clear();
        self.mainboard.clear();
        self.cloud.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutOfSyncItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutOfSyncItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutOfSyncResponse {
    // message fields
    pub unsyncItems: ::std::collections::HashMap<::std::string::String, OutOfSyncItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutOfSyncResponse {
    fn default() -> &'a OutOfSyncResponse {
        <OutOfSyncResponse as ::protobuf::Message>::default_instance()
    }
}

impl OutOfSyncResponse {
    pub fn new() -> OutOfSyncResponse {
        ::std::default::Default::default()
    }

    // repeated .OutOfSyncResponse.UnsyncItemsEntry unsyncItems = 1;


    pub fn get_unsyncItems(&self) -> &::std::collections::HashMap<::std::string::String, OutOfSyncItem> {
        &self.unsyncItems
    }
    pub fn clear_unsyncItems(&mut self) {
        self.unsyncItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_unsyncItems(&mut self, v: ::std::collections::HashMap<::std::string::String, OutOfSyncItem>) {
        self.unsyncItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unsyncItems(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, OutOfSyncItem> {
        &mut self.unsyncItems
    }

    // Take field
    pub fn take_unsyncItems(&mut self) -> ::std::collections::HashMap<::std::string::String, OutOfSyncItem> {
        ::std::mem::replace(&mut self.unsyncItems, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for OutOfSyncResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<OutOfSyncItem>>(wire_type, is, &mut self.unsyncItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<OutOfSyncItem>>(1, &self.unsyncItems);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<OutOfSyncItem>>(1, &self.unsyncItems, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutOfSyncResponse {
        OutOfSyncResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<OutOfSyncItem>>(
                "unsyncItems",
                |m: &OutOfSyncResponse| { &m.unsyncItems },
                |m: &mut OutOfSyncResponse| { &mut m.unsyncItems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutOfSyncResponse>(
                "OutOfSyncResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutOfSyncResponse {
        static instance: ::protobuf::rt::LazyV2<OutOfSyncResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutOfSyncResponse::new)
    }
}

impl ::protobuf::Clear for OutOfSyncResponse {
    fn clear(&mut self) {
        self.unsyncItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutOfSyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutOfSyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutOfSyncRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutOfSyncRequest {
    fn default() -> &'a OutOfSyncRequest {
        <OutOfSyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl OutOfSyncRequest {
    pub fn new() -> OutOfSyncRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OutOfSyncRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutOfSyncRequest {
        OutOfSyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutOfSyncRequest>(
                "OutOfSyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutOfSyncRequest {
        static instance: ::protobuf::rt::LazyV2<OutOfSyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutOfSyncRequest::new)
    }
}

impl ::protobuf::Clear for OutOfSyncRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutOfSyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutOfSyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncItem {
    // message fields
    pub ressource: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncItem {
    fn default() -> &'a SyncItem {
        <SyncItem as ::protobuf::Message>::default_instance()
    }
}

impl SyncItem {
    pub fn new() -> SyncItem {
        ::std::default::Default::default()
    }

    // string ressource = 1;


    pub fn get_ressource(&self) -> &str {
        &self.ressource
    }
    pub fn clear_ressource(&mut self) {
        self.ressource.clear();
    }

    // Param is passed by value, moved
    pub fn set_ressource(&mut self, v: ::std::string::String) {
        self.ressource = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ressource(&mut self) -> &mut ::std::string::String {
        &mut self.ressource
    }

    // Take field
    pub fn take_ressource(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ressource, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SyncItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ressource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ressource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ressource);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ressource.is_empty() {
            os.write_string(1, &self.ressource)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncItem {
        SyncItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ressource",
                |m: &SyncItem| { &m.ressource },
                |m: &mut SyncItem| { &mut m.ressource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncItem>(
                "SyncItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncItem {
        static instance: ::protobuf::rt::LazyV2<SyncItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncItem::new)
    }
}

impl ::protobuf::Clear for SyncItem {
    fn clear(&mut self) {
        self.ressource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncRequest {
    // message fields
    pub toSyncItems: ::std::collections::HashMap<::std::string::String, SyncItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncRequest {
    fn default() -> &'a SyncRequest {
        <SyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncRequest {
    pub fn new() -> SyncRequest {
        ::std::default::Default::default()
    }

    // repeated .SyncRequest.ToSyncItemsEntry toSyncItems = 1;


    pub fn get_toSyncItems(&self) -> &::std::collections::HashMap<::std::string::String, SyncItem> {
        &self.toSyncItems
    }
    pub fn clear_toSyncItems(&mut self) {
        self.toSyncItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_toSyncItems(&mut self, v: ::std::collections::HashMap<::std::string::String, SyncItem>) {
        self.toSyncItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toSyncItems(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, SyncItem> {
        &mut self.toSyncItems
    }

    // Take field
    pub fn take_toSyncItems(&mut self) -> ::std::collections::HashMap<::std::string::String, SyncItem> {
        ::std::mem::replace(&mut self.toSyncItems, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SyncRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncItem>>(wire_type, is, &mut self.toSyncItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncItem>>(1, &self.toSyncItems);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncItem>>(1, &self.toSyncItems, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncRequest {
        SyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<SyncItem>>(
                "toSyncItems",
                |m: &SyncRequest| { &m.toSyncItems },
                |m: &mut SyncRequest| { &mut m.toSyncItems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncRequest>(
                "SyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncRequest {
        static instance: ::protobuf::rt::LazyV2<SyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncRequest::new)
    }
}

impl ::protobuf::Clear for SyncRequest {
    fn clear(&mut self) {
        self.toSyncItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nsync.proto\"<\n\x08SyncInfo\x12\x12\n\x04hash\x18\x01\x20\x01(\tR\
    \x04hash\x12\x1c\n\tupdatedAt\x18\x02\x20\x01(\rR\tupdatedAt\"\xa5\x01\n\
    \x15GlobalSyncInformation\x12C\n\tsyncItems\x18\x01\x20\x03(\x0b2%.Globa\
    lSyncInformation.SyncItemsEntryR\tsyncItems\x1aG\n\x0eSyncItemsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1f\n\x05value\x18\x02\x20\
    \x01(\x0b2\t.SyncInfoR\x05value:\x028\x01\"w\n\rOutOfSyncItem\x12\x1c\n\
    \tressource\x18\x01\x20\x01(\tR\tressource\x12'\n\tmainboard\x18\x02\x20\
    \x01(\x0b2\t.SyncInfoR\tmainboard\x12\x1f\n\x05cloud\x18\x03\x20\x01(\
    \x0b2\t.SyncInfoR\x05cloud\"\xaa\x01\n\x11OutOfSyncResponse\x12E\n\x0bun\
    syncItems\x18\x01\x20\x03(\x0b2#.OutOfSyncResponse.UnsyncItemsEntryR\x0b\
    unsyncItems\x1aN\n\x10UnsyncItemsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12$\n\x05value\x18\x02\x20\x01(\x0b2\x0e.OutOfSyncItemR\x05v\
    alue:\x028\x01\"\x12\n\x10OutOfSyncRequest\"(\n\x08SyncItem\x12\x1c\n\tr\
    essource\x18\x01\x20\x01(\tR\tressource\"\x99\x01\n\x0bSyncRequest\x12?\
    \n\x0btoSyncItems\x18\x01\x20\x03(\x0b2\x1d.SyncRequest.ToSyncItemsEntry\
    R\x0btoSyncItems\x1aI\n\x10ToSyncItemsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x1f\n\x05value\x18\x02\x20\x01(\x0b2\t.SyncItemR\x05\
    value:\x028\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
